{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Baltica: integrated splice junction usage analysis \u00b6 Features \u00b6 - Snakemake workflows for DJU: `junctionseq`, `majiq`, `rmats`, and `leafcutter` - Snakemake workflow for de novo transcriptome annotation with `stringtie` - Process, integrate and annotate the results from the methods - Summarise AS class of differently spliced junctions - DJU method benchmarks - Report on the integrative analysis To get started , use the menu on the left-hand side or search function to navigate over this documentation. Citation \u00b6 Thiago Britto-Borges, Volker Boehm, Niels H. Gehring and Christoph Dieterich (2020) Baltica: integrated splice junction usage analysis . Manuscript in preparation. Baltica is based on the work of many scientists and developers. Thus, if you use the results of their tools in your analysis, consider citing their work. License \u00b6 Baltica is free, open-source software released under an MIT License . Contact \u00b6 Please get in touch with us the GitHub issue tracker .","title":"Index"},{"location":"index.html#baltica-integrated-splice-junction-usage-analysis","text":"","title":"Baltica: integrated splice junction usage analysis"},{"location":"index.html#features","text":"- Snakemake workflows for DJU: `junctionseq`, `majiq`, `rmats`, and `leafcutter` - Snakemake workflow for de novo transcriptome annotation with `stringtie` - Process, integrate and annotate the results from the methods - Summarise AS class of differently spliced junctions - DJU method benchmarks - Report on the integrative analysis To get started , use the menu on the left-hand side or search function to navigate over this documentation.","title":"Features"},{"location":"index.html#citation","text":"Thiago Britto-Borges, Volker Boehm, Niels H. Gehring and Christoph Dieterich (2020) Baltica: integrated splice junction usage analysis . Manuscript in preparation. Baltica is based on the work of many scientists and developers. Thus, if you use the results of their tools in your analysis, consider citing their work.","title":"Citation"},{"location":"index.html#license","text":"Baltica is free, open-source software released under an MIT License .","title":"License"},{"location":"index.html#contact","text":"Please get in touch with us the GitHub issue tracker .","title":"Contact"},{"location":"analysis.html","text":"AA \u00b6 Result files are parsed and transformed to tidy format: - each row presents a junction and pair-wise comparison at a first moment, we don't filter any results based on the probability of obtaining the observed results of a test, giving a null hypothesis is true (p-value) or effect size change (deltaPSI). This is done in a second step with files with 'annotated' Difference in interpretation among the tools: Analysis design For Junctionseq model include all conditions at once Majiq pairwise, Leafcutter currently pairwise, although it also supports more complex design As result, SJ from JunctionSeq have single p-value, while multiple Arbitrary cutoffs: - Majiq: xx == 1 & deltapsi - Leafcutter: padj < 0.05 - JunctionSeq:","title":"AA"},{"location":"analysis.html#aa","text":"Result files are parsed and transformed to tidy format: - each row presents a junction and pair-wise comparison at a first moment, we don't filter any results based on the probability of obtaining the observed results of a test, giving a null hypothesis is true (p-value) or effect size change (deltaPSI). This is done in a second step with files with 'annotated' Difference in interpretation among the tools: Analysis design For Junctionseq model include all conditions at once Majiq pairwise, Leafcutter currently pairwise, although it also supports more complex design As result, SJ from JunctionSeq have single p-value, while multiple Arbitrary cutoffs: - Majiq: xx == 1 & deltapsi - Leafcutter: padj < 0.05 - JunctionSeq:","title":"AA"},{"location":"benchmark.html","text":"We implemented a benchmark method for DJU methods using the Spike-In RNA Variants (SIRVs Set-1, cat 025.03 1 ) as ground-truth for alternative splicing identification. Differential splicing methods often use simulated data for benchmark, which does not fully appreciate the complexity of RNA-Sequencing experiment. We use a complementary approach that aims to overcome this limitation. The SIRVs spike-in comprise seven genes, 69 transcript isoforms, 357 exons and 113 intron According to our experimental design ( Fig. 5.1 ), differences in transcript abundance lead to differential splicing events in SIRV chromosomes but not in the human contigs, which would represent false-positive calls. To benchmark the dataset, we use Baltica to run the three tools comparing three groups: - mix 2 versus mix 1 - mix 3 versus mix 2 - mix 3 versus mix 1 Important The test data currently shipping with Baltica has only a subset of 10% of the reads per group in Gerbracht et al. 2020 ( E-MTAB-8461 ). Fig. 5.1: Experimental design : The first column represents the experimental groups. See 2 for detail on the biological differences among groups. The second column represents the SIRV mixes. The third column is the sample id from the sequencing facility. RNA-Seq processing and mapping \u00b6 Cell lines, RNA extraction, and RNA-Seq were described by 2 . In short, we obtained 15 libraries from Flp-In T-REx 293 cells, extracted the RNA fraction, with TrueSeq Stranded Total RNA kit (Illumina), followed by ribosomal RNA depletion, with RiboGold Plus kit. Reads were sequenced with an Illumina HiSeq4000 sequencer using PE 100bp protocol and yield around 50 million reads per sample. Data is deposited in ArrayExpress (E-MTAB-8461). Sequenced reads' adapters and low-quality bases were trimmed, and reads mapping to human precursor ribosomal RNA were discarded. The remaining reads were aligned to the human transcriptome (version 38, EnsEMBL 90) extended with the SIRV annotation. Regarding the DJU method benchmarking, we are not interested in the biological condition, but the SIRVs AS event, and so this experiment was designed, so the SIRVs mixes were not confounded to the biological factors. DJU method produces results with little agreement \u00b6 To demonstrated the previously observed lack of consensus among DJU methods, we computed DJU with JunctionSeq, Majiq, and Leafcutter with the SIRVs, for three mixes containing a variable abundance of each transcript. The difference abundances are equivalent to differences in junction usage. The mixes were incorporated into the RNA-Seq experiment in non-confounded design with the biological co-variates, so the SJ observed in the natural contigs (human chromosome) could be used as false-positive calls. Table 5.1 shows the number of SJ identified and called significant ( see the Workflow Chapter for detains on how the we reconcile these results). Majiq and JunctionSeq call around 310 significant SJ, while Leafcutter calls 201. Overall, the methods produce a comparable number of SJ called significant. - Junctionseq Majiq Leafcutter Total 608 2850 131676 Significant 311 309 201 Table 5.1 : Number of SJ considered (Total) and called significant (Significant) for each method. However, when comparing the resulting gene and SJ sets, we observe a limited intersection among the results from the three methods ( Fig. 5.2 ) for genes and SJ. To further understand this issue, we reviewed the step-by-step process implemented by the methods. Overall, the three DJU methods share three steps, as mentioned before: Reads are extracted and filtered from the read alignments. Testable SJ or splicing events are identified, for example, by clustering. The SJ or splicing events counts are modelled. Fig. 5.2: Overlap between genes and SJ called significant by three DJU methods. JunctionSeq, Majiq and, Leafcutter deliver results that show a limited agreement among each other. We computed differential junction usage using the three methods on 15 RNA-Seq libraries with 3 groups, the three SIRV mixes. The resulting intersection shows that only small overlap genes ( A ) and SJ ( B ) called significant by the tools 9% (6 out of 66) and 16% (34 out of 212), respectively. Benchmark \u00b6 We extracted all introns from the SIRV transcripts and classified between diff (changing between mixes) and no diff. Given the binary outcome from each tool, we analysed the following cases: True positive: diff intron called significant False-positive: no diff intron or intron in human contig called significant True negative: no diff not called significant False-negative: diff intron not called significant Results from the methods benchmark \u00b6 TN FP FN TP Majiq 2492 126 90 82 JunctionSeq 273 43 24 268 Leafcutter 131474 43 1 158 Table 5.2: Methods and number of SJ in each classification case Junctionseq achieves the highest number of TP calls and Junctionseq and Leafcutter the lowest number of FP calls. Based on that procedure, we proceeded with a two-class validation and computed the Receiver Operating Characteristic (ROC) curve and the precision-recall curve. Fig 5.3 ROC and Precision-recall curve : we observe the in this benchmark JunctionSeq outperforms Majiq and Leafcutter. The curves shows that Junctionseq outperforms the other two methods in the conditions we have analysed. Despite the punctual similarities, the implementation of these three state-of-art methods vary. Here we present a direct comparison on a set of artificial transcripts. The cumulative differences in who to define which SJ are extracted and tested; how much the method relies on the annotation; and the framework for statistical modelling explain the small intersections in Fig. 5.2 . In this case, Leafcutter suffers from a recall ceiling issue, because it ignores certain introns from the artificial transcripts. JunctionSeq has a clear advantage in this comparison because it relies heavily on the information of the annotation and the input annotation, that in this case, perfectly represents the structure of the transcripts. Majiq suffers from an excess of false-positive calls. Baltica aims to further study these implementations differences and potentially suggestion advice to minimize the effect of the limitations mentioned above. https://www.lexogen.com/sirvs/#sirvsdownload - Lexogen took no part in the experimental design neither we have any relationship with the company. \u21a9 Jennifer V Gerbracht, Volker Boehm, Thiago Britto-Borges, Sebastian Kallabis, Janica L Wiederstein, Simona Ciriello, Dominik U Aschemeier, Marcus Kr\u00fcger, Christian K Frese, Janine Altm\u00fcller, and et al. Casc3 promotes transcriptome-wide activation of nonsense-mediated decay by the exon junction complex. Nucleic Acids Research , Jul 2020. URL: http://dx.doi.org/10.1093/nar/gkaa564 , doi:10.1093/nar/gkaa564 . \u21a9 \u21a9","title":"Benchmark"},{"location":"benchmark.html#rna-seq-processing-and-mapping","text":"Cell lines, RNA extraction, and RNA-Seq were described by 2 . In short, we obtained 15 libraries from Flp-In T-REx 293 cells, extracted the RNA fraction, with TrueSeq Stranded Total RNA kit (Illumina), followed by ribosomal RNA depletion, with RiboGold Plus kit. Reads were sequenced with an Illumina HiSeq4000 sequencer using PE 100bp protocol and yield around 50 million reads per sample. Data is deposited in ArrayExpress (E-MTAB-8461). Sequenced reads' adapters and low-quality bases were trimmed, and reads mapping to human precursor ribosomal RNA were discarded. The remaining reads were aligned to the human transcriptome (version 38, EnsEMBL 90) extended with the SIRV annotation. Regarding the DJU method benchmarking, we are not interested in the biological condition, but the SIRVs AS event, and so this experiment was designed, so the SIRVs mixes were not confounded to the biological factors.","title":"RNA-Seq processing and mapping"},{"location":"benchmark.html#dju-method-produces-results-with-little-agreement","text":"To demonstrated the previously observed lack of consensus among DJU methods, we computed DJU with JunctionSeq, Majiq, and Leafcutter with the SIRVs, for three mixes containing a variable abundance of each transcript. The difference abundances are equivalent to differences in junction usage. The mixes were incorporated into the RNA-Seq experiment in non-confounded design with the biological co-variates, so the SJ observed in the natural contigs (human chromosome) could be used as false-positive calls. Table 5.1 shows the number of SJ identified and called significant ( see the Workflow Chapter for detains on how the we reconcile these results). Majiq and JunctionSeq call around 310 significant SJ, while Leafcutter calls 201. Overall, the methods produce a comparable number of SJ called significant. - Junctionseq Majiq Leafcutter Total 608 2850 131676 Significant 311 309 201 Table 5.1 : Number of SJ considered (Total) and called significant (Significant) for each method. However, when comparing the resulting gene and SJ sets, we observe a limited intersection among the results from the three methods ( Fig. 5.2 ) for genes and SJ. To further understand this issue, we reviewed the step-by-step process implemented by the methods. Overall, the three DJU methods share three steps, as mentioned before: Reads are extracted and filtered from the read alignments. Testable SJ or splicing events are identified, for example, by clustering. The SJ or splicing events counts are modelled. Fig. 5.2: Overlap between genes and SJ called significant by three DJU methods. JunctionSeq, Majiq and, Leafcutter deliver results that show a limited agreement among each other. We computed differential junction usage using the three methods on 15 RNA-Seq libraries with 3 groups, the three SIRV mixes. The resulting intersection shows that only small overlap genes ( A ) and SJ ( B ) called significant by the tools 9% (6 out of 66) and 16% (34 out of 212), respectively.","title":"DJU method produces results with little agreement"},{"location":"benchmark.html#benchmark","text":"We extracted all introns from the SIRV transcripts and classified between diff (changing between mixes) and no diff. Given the binary outcome from each tool, we analysed the following cases: True positive: diff intron called significant False-positive: no diff intron or intron in human contig called significant True negative: no diff not called significant False-negative: diff intron not called significant","title":"Benchmark"},{"location":"benchmark.html#results-from-the-methods-benchmark","text":"TN FP FN TP Majiq 2492 126 90 82 JunctionSeq 273 43 24 268 Leafcutter 131474 43 1 158 Table 5.2: Methods and number of SJ in each classification case Junctionseq achieves the highest number of TP calls and Junctionseq and Leafcutter the lowest number of FP calls. Based on that procedure, we proceeded with a two-class validation and computed the Receiver Operating Characteristic (ROC) curve and the precision-recall curve. Fig 5.3 ROC and Precision-recall curve : we observe the in this benchmark JunctionSeq outperforms Majiq and Leafcutter. The curves shows that Junctionseq outperforms the other two methods in the conditions we have analysed. Despite the punctual similarities, the implementation of these three state-of-art methods vary. Here we present a direct comparison on a set of artificial transcripts. The cumulative differences in who to define which SJ are extracted and tested; how much the method relies on the annotation; and the framework for statistical modelling explain the small intersections in Fig. 5.2 . In this case, Leafcutter suffers from a recall ceiling issue, because it ignores certain introns from the artificial transcripts. JunctionSeq has a clear advantage in this comparison because it relies heavily on the information of the annotation and the input annotation, that in this case, perfectly represents the structure of the transcripts. Majiq suffers from an excess of false-positive calls. Baltica aims to further study these implementations differences and potentially suggestion advice to minimize the effect of the limitations mentioned above. https://www.lexogen.com/sirvs/#sirvsdownload - Lexogen took no part in the experimental design neither we have any relationship with the company. \u21a9 Jennifer V Gerbracht, Volker Boehm, Thiago Britto-Borges, Sebastian Kallabis, Janica L Wiederstein, Simona Ciriello, Dominik U Aschemeier, Marcus Kr\u00fcger, Christian K Frese, Janine Altm\u00fcller, and et al. Casc3 promotes transcriptome-wide activation of nonsense-mediated decay by the exon junction complex. Nucleic Acids Research , Jul 2020. URL: http://dx.doi.org/10.1093/nar/gkaa564 , doi:10.1093/nar/gkaa564 . \u21a9 \u21a9","title":"Results from the methods benchmark"},{"location":"bibliography.html","text":"1: Jennifer V Gerbracht, Volker Boehm, Thiago Britto-Borges, Sebastian Kallabis, Janica L Wiederstein, Simona Ciriello, Dominik U Aschemeier, Marcus Kr\u00fcger, Christian K Frese, Janine Altm\u00fcller, and et al. Casc3 promotes transcriptome-wide activation of nonsense-mediated decay by the exon junction complex. Nucleic Acids Research , Jul 2020. URL: http://dx.doi.org/10.1093/nar/gkaa564 , doi:10.1093/nar/gkaa564 .","title":"Bibliography"},{"location":"dev_guide.html","text":"Development guidelines: \u00b6 For the docs, we use MkDocs because of its flexibility: - mkdocs-material : look and feel - mkdocs-bibtex : literature reference - MkPDFs : PDF version Setting up mkdocs \u00b6 # osx specific settings conda install pango cairo pip install mkdocs pip install mkdocs-material pip install mkdocs-bibtex pip install -e git+https://github.com/jwaschkau/mkpdfs-mkdocs-plugin.git#egg = mkpdfs-mkdocs-plugin # osx specific settings export LC_ALL = en_US.UTF-8 export LANG = en_US.UTF-8 Contributing to the documentation \u00b6 Modify any of the doc files \u00b6 vi docs/setup.md Test the changes locally \u00b6 mkdocs serve If everything looks fine you can submit a patch or pull-request. Deploy changes \u00b6 This requires permissions from the GitHub organization. mkdocs gh-deploy Testing Baltica \u00b6 Baltica's continuous integration testing suite is under development.","title":"Development guidelines"},{"location":"dev_guide.html#development-guidelines","text":"For the docs, we use MkDocs because of its flexibility: - mkdocs-material : look and feel - mkdocs-bibtex : literature reference - MkPDFs : PDF version","title":"Development guidelines:"},{"location":"dev_guide.html#setting-up-mkdocs","text":"# osx specific settings conda install pango cairo pip install mkdocs pip install mkdocs-material pip install mkdocs-bibtex pip install -e git+https://github.com/jwaschkau/mkpdfs-mkdocs-plugin.git#egg = mkpdfs-mkdocs-plugin # osx specific settings export LC_ALL = en_US.UTF-8 export LANG = en_US.UTF-8","title":"Setting up mkdocs"},{"location":"dev_guide.html#contributing-to-the-documentation","text":"","title":"Contributing to the documentation"},{"location":"dev_guide.html#modify-any-of-the-doc-files","text":"vi docs/setup.md","title":"Modify any of the doc files"},{"location":"dev_guide.html#test-the-changes-locally","text":"mkdocs serve If everything looks fine you can submit a patch or pull-request.","title":"Test the changes locally"},{"location":"dev_guide.html#deploy-changes","text":"This requires permissions from the GitHub organization. mkdocs gh-deploy","title":"Deploy changes"},{"location":"dev_guide.html#testing-baltica","text":"Baltica's continuous integration testing suite is under development.","title":"Testing Baltica"},{"location":"faq.html","text":"What you mean with baltica provides a interface between users and DJU methods : \u00b6 There are many specificities to the DJU methods, and while running one method is not too complicated, figuring out how to run multiple methods is time-demanding. Baltica aims to facilitate this task so that methods results can be produced and compared. Snakemake Error: Directory cannot be locked. : \u00b6 This error happens when there is an error or failure during the workflow execution, and Snakemake's process does not have the opportunity to unlock the directory. Use baltica <workflow> <config> --unlock to resolve it. See more here rmats empty or mostly empty outputs \u00b6 This error can be either issue with: - The read length parameter . To resolve it, increase the read length parameter or use --variable-read-length in Baltica configuration. - Or an error with the stack size limit . To resolve it increase the stack size in bash with ulimit -c unlimited . Junctionseq bpapply error: \u00b6 This error occurs in the junctionseq_analysis rule, which uses multiple threads with BiocParallel. One can overcome this issue by setting threads to 1 on the said rule. Junctionseq analysis thread error \u00b6 Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index xxx out of bounds for length xxx It is complaining the maximum read length is longer than the read length input. First, check the maximum read length in the quality control report and then increase the read_len parameter on Baltica config. How does Baltica compute the score for each DJU method? \u00b6 The different DJU methods are pretty different in many aspects, including how they compute the final test statistic, and we use the following rule to compute the score for the Baltica table (higher is better): - majiq score = 1 - non-changing-threshold (probability of |\u0394\u03a8| > 0.2, by default) - leafcutter = 1 - p.adjust - junctionseq = 1 - padjust - rmats = 1 - FDR I see a message: /bin/bash: /root/.bashrc: Permission denied . What is wrong? \u00b6 This error message is benign and, in our experience, does not affect workflow execution.","title":"Frequently asked questions"},{"location":"faq.html#what-you-mean-with-baltica-provides-a-interface-between-users-and-dju-methods","text":"There are many specificities to the DJU methods, and while running one method is not too complicated, figuring out how to run multiple methods is time-demanding. Baltica aims to facilitate this task so that methods results can be produced and compared.","title":"What you mean with baltica provides a interface between users and DJU methods:"},{"location":"faq.html#snakemake-error-directory-cannot-be-locked","text":"This error happens when there is an error or failure during the workflow execution, and Snakemake's process does not have the opportunity to unlock the directory. Use baltica <workflow> <config> --unlock to resolve it. See more here","title":"Snakemake Error: Directory cannot be locked.:"},{"location":"faq.html#rmats-empty-or-mostly-empty-outputs","text":"This error can be either issue with: - The read length parameter . To resolve it, increase the read length parameter or use --variable-read-length in Baltica configuration. - Or an error with the stack size limit . To resolve it increase the stack size in bash with ulimit -c unlimited .","title":"rmats empty or mostly empty outputs"},{"location":"faq.html#junctionseq-bpapply-error","text":"This error occurs in the junctionseq_analysis rule, which uses multiple threads with BiocParallel. One can overcome this issue by setting threads to 1 on the said rule.","title":"Junctionseq bpapply error:"},{"location":"faq.html#junctionseq-analysis-thread-error","text":"Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index xxx out of bounds for length xxx It is complaining the maximum read length is longer than the read length input. First, check the maximum read length in the quality control report and then increase the read_len parameter on Baltica config.","title":"Junctionseq analysis thread error"},{"location":"faq.html#how-does-baltica-compute-the-score-for-each-dju-method","text":"The different DJU methods are pretty different in many aspects, including how they compute the final test statistic, and we use the following rule to compute the score for the Baltica table (higher is better): - majiq score = 1 - non-changing-threshold (probability of |\u0394\u03a8| > 0.2, by default) - leafcutter = 1 - p.adjust - junctionseq = 1 - padjust - rmats = 1 - FDR","title":"How does Baltica compute the score for each DJU method?"},{"location":"faq.html#i-see-a-message-binbash-rootbashrc-permission-denied-what-is-wrong","text":"This error message is benign and, in our experience, does not affect workflow execution.","title":"I see a message: /bin/bash: /root/.bashrc: Permission denied. What is wrong?"},{"location":"integration.html","text":"Parsing the results of the method \u00b6 The first step in the analysis workflow is parsing and processing the DJU methods' output with scripts/parse_{method}_output.R scripts as follows: The resulting text output from the DJU methods is parsed and loaded as R data frames The data frames are pivoted in a longer format to have one junction and one comparison per row Warning rmats, majiq, and leafcutter use AS events to test for DJU, so metrics are associated with a group and not the SJ. In Baltica, we split these groups in SJ, and multiple SJ may have the same metric, for example, test statistics. Warning majiq and rmats may be assigned multiple scores to an SJ to different AS types. For these, Baltica selects the maximum score as the representative. Annotating the results \u00b6 We annotate the results with information from the gene and transcript hosting the SJ. For this, we use the de novo transcript annotation at stringtie/merged/merged.combined.gtf . It's common the multiple transcripts share an intron, and so a single intron may be annotated with multiple transcripts. One challenge for the integration of DJU methods' results is the different genomic coordinates system. The coordinates system's differences are due to the method implementation design: methods can be 0-indexed (BED format) versus 1-indexed (GTF format) or use the exonic versus intronic coordinates to represent the SJ genomic position. We propose a filter_hits_by_diff that discards any hits with more than two bp differences from overlapping features between the reference (query) and the SJ (subject). Then, using introns obtained in that annotation as a reference and filter_hits_by_diff , Baltica enables the reconciliation of the multiple DJU results. These are the columns assigned after the annotation: Column name Description Note comparison pairwise comparison as {case}_vs_{control} chr seqname or genomic contig start intron start position for the SJ 1-index end intron end position 1-index strand RNA strand that encodes that gene gene the gene symbol e2 acceptor exon number, if in + strand otherwise donor exon e1 donor exon number, if in the + strand otherwise acceptor exon tx_id transcript identifier from the combined annotation transcript_name transcript name class_code association between reference transcript and novel transcript see fig 1 from this paper for details Table 1: Columns added after annotation Selecting optimal parameters for de novo transcriptome assembly \u00b6 We found that the parameters used to obtain the de novo transcriptome are critical for maximum integration between the GTF and the SJ from DJU methods. Fig 1 shows a parameter scan where we vary the group, -j (minimum junction coverage), -c (minimum coverage), and -f (minimum isoform proportion) and compute the number of transcripts that match with SJ called significantly. As expected, the merged annotation and not the group-specific annotation have the highest rate of annotated introns. The crucial result here is the dependency of the -f parameter, which is also associated with an increased number of annotated introns. As we confirmed this behavior in other datasets, we decided to use -c 3 -j 3 -f 0.01 as default values in Baltica. The higher coverage ( -c and -j ) values counter the potential noise of transcripts with low abundance. Fig. 6.1: Parameters scan to maximize the number of introns annotated We have run Stringtie with multiple for group annotations and merged annotation. We use a series of parameters: junction coverage of 1, 2, or 3; coverage of 1, 2, 3, and minimum isoform fraction of 0.1, 0.01, or 0.001. Assigning AS type \u00b6 Biolofical motivation \u00b6 Identifying the type of AS is critical to understand a potential molecular mechanism for AS events. Many factors influence splicing. Splicing factors are probably the most well-studied and can have a specific function in splicing regulation. SRSF2 is a relevant example in this context. SRSF2 is splicing factors from the SR family that are known for auto-regulation. In certain conditions, the SRSF2 transcript can activate the nonsense-mediated decay by either including a new exon containing a premature stop codon or an intron in 3' UTR. These changes lead to transcript degradation and overall reduction of gene expression. Thus, the reduction of SRSF2 protein level leads to widespread exon skipping. Identifying such patterns is critical to understanding which splicing regulators are driving the observed splicing changes. Implementation \u00b6 In Baltica, we use a geometric approach to define AS in three classes: - ES, for exon skipping - A3SS, for alternative 3' splice-site - A5SS, for alternative 5' splice-site Figure 2 details how we use the distance between features start and end to determine the AS type. Fig. 2: AS type assignment in Baltica. Baltica uses the genomic coordinates from the SJ and its overlapping exons to assigning AS type to SJ and its overlapping exons. Because many exons may be affected, multiple assignments are output. For example, donor and acceptor exons are assigned as JS and JE, respectively. Simplify the AS event \u00b6 Because most of the final users are only interested in the list of genomic ranges, gene names, or event types, we offer a simplified output that removes redundant information. This step helps generate a final report.","title":"DJU methods result integration"},{"location":"integration.html#parsing-the-results-of-the-method","text":"The first step in the analysis workflow is parsing and processing the DJU methods' output with scripts/parse_{method}_output.R scripts as follows: The resulting text output from the DJU methods is parsed and loaded as R data frames The data frames are pivoted in a longer format to have one junction and one comparison per row Warning rmats, majiq, and leafcutter use AS events to test for DJU, so metrics are associated with a group and not the SJ. In Baltica, we split these groups in SJ, and multiple SJ may have the same metric, for example, test statistics. Warning majiq and rmats may be assigned multiple scores to an SJ to different AS types. For these, Baltica selects the maximum score as the representative.","title":"Parsing the results of the method"},{"location":"integration.html#annotating-the-results","text":"We annotate the results with information from the gene and transcript hosting the SJ. For this, we use the de novo transcript annotation at stringtie/merged/merged.combined.gtf . It's common the multiple transcripts share an intron, and so a single intron may be annotated with multiple transcripts. One challenge for the integration of DJU methods' results is the different genomic coordinates system. The coordinates system's differences are due to the method implementation design: methods can be 0-indexed (BED format) versus 1-indexed (GTF format) or use the exonic versus intronic coordinates to represent the SJ genomic position. We propose a filter_hits_by_diff that discards any hits with more than two bp differences from overlapping features between the reference (query) and the SJ (subject). Then, using introns obtained in that annotation as a reference and filter_hits_by_diff , Baltica enables the reconciliation of the multiple DJU results. These are the columns assigned after the annotation: Column name Description Note comparison pairwise comparison as {case}_vs_{control} chr seqname or genomic contig start intron start position for the SJ 1-index end intron end position 1-index strand RNA strand that encodes that gene gene the gene symbol e2 acceptor exon number, if in + strand otherwise donor exon e1 donor exon number, if in the + strand otherwise acceptor exon tx_id transcript identifier from the combined annotation transcript_name transcript name class_code association between reference transcript and novel transcript see fig 1 from this paper for details Table 1: Columns added after annotation","title":"Annotating the results"},{"location":"integration.html#selecting-optimal-parameters-for-de-novo-transcriptome-assembly","text":"We found that the parameters used to obtain the de novo transcriptome are critical for maximum integration between the GTF and the SJ from DJU methods. Fig 1 shows a parameter scan where we vary the group, -j (minimum junction coverage), -c (minimum coverage), and -f (minimum isoform proportion) and compute the number of transcripts that match with SJ called significantly. As expected, the merged annotation and not the group-specific annotation have the highest rate of annotated introns. The crucial result here is the dependency of the -f parameter, which is also associated with an increased number of annotated introns. As we confirmed this behavior in other datasets, we decided to use -c 3 -j 3 -f 0.01 as default values in Baltica. The higher coverage ( -c and -j ) values counter the potential noise of transcripts with low abundance. Fig. 6.1: Parameters scan to maximize the number of introns annotated We have run Stringtie with multiple for group annotations and merged annotation. We use a series of parameters: junction coverage of 1, 2, or 3; coverage of 1, 2, 3, and minimum isoform fraction of 0.1, 0.01, or 0.001.","title":"Selecting optimal parameters for de novo transcriptome assembly"},{"location":"integration.html#assigning-as-type","text":"","title":"Assigning AS type"},{"location":"integration.html#biolofical-motivation","text":"Identifying the type of AS is critical to understand a potential molecular mechanism for AS events. Many factors influence splicing. Splicing factors are probably the most well-studied and can have a specific function in splicing regulation. SRSF2 is a relevant example in this context. SRSF2 is splicing factors from the SR family that are known for auto-regulation. In certain conditions, the SRSF2 transcript can activate the nonsense-mediated decay by either including a new exon containing a premature stop codon or an intron in 3' UTR. These changes lead to transcript degradation and overall reduction of gene expression. Thus, the reduction of SRSF2 protein level leads to widespread exon skipping. Identifying such patterns is critical to understanding which splicing regulators are driving the observed splicing changes.","title":"Biolofical motivation"},{"location":"integration.html#implementation","text":"In Baltica, we use a geometric approach to define AS in three classes: - ES, for exon skipping - A3SS, for alternative 3' splice-site - A5SS, for alternative 5' splice-site Figure 2 details how we use the distance between features start and end to determine the AS type. Fig. 2: AS type assignment in Baltica. Baltica uses the genomic coordinates from the SJ and its overlapping exons to assigning AS type to SJ and its overlapping exons. Because many exons may be affected, multiple assignments are output. For example, donor and acceptor exons are assigned as JS and JE, respectively.","title":"Implementation"},{"location":"integration.html#simplify-the-as-event","text":"Because most of the final users are only interested in the list of genomic ranges, gene names, or event types, we offer a simplified output that removes redundant information. This step helps generate a final report.","title":"Simplify the AS event"},{"location":"intro.html","text":"Introduction \u00b6 For motivation and review of state of the art, please check: Thiago Britto-Borges, Volker Boehm, Niels H. Gehring and Christoph Dieterich (2020) Baltica: integrated splice junction usage analysis. Manuscript in preparation. Tips on RNA-Seq aiming differential splicing detection \u00b6 If you aim to resolve mRNA isoforms with relatively low abundance, you should design the RNA-seq experiment accordingly. The expert suggestion is to sequence around 40 to 60 million reads pairs. This parameter is particularly relevant for complex RNA libraries, but it can be insufficient to saturate novel SJ, in our experience. Read length and paired-end reads are also critical for SJ identification, and longer reads offer more coverage of the exons boundaries. Thus, the target read length should be around 100 nucleotides for Illumina RNA-seq to maximize the read overhang length and, consequently, maximize the quality of the alignments. In the Baltica manuscript, we propose an approach to integrate DJU results from Illumina to DJU results from third-generation sequencing. Also, databases such as the CHESS can provide additional evidence for splice sites absent in the annotation.","title":"Introduction"},{"location":"intro.html#introduction","text":"For motivation and review of state of the art, please check: Thiago Britto-Borges, Volker Boehm, Niels H. Gehring and Christoph Dieterich (2020) Baltica: integrated splice junction usage analysis. Manuscript in preparation.","title":"Introduction"},{"location":"intro.html#tips-on-rna-seq-aiming-differential-splicing-detection","text":"If you aim to resolve mRNA isoforms with relatively low abundance, you should design the RNA-seq experiment accordingly. The expert suggestion is to sequence around 40 to 60 million reads pairs. This parameter is particularly relevant for complex RNA libraries, but it can be insufficient to saturate novel SJ, in our experience. Read length and paired-end reads are also critical for SJ identification, and longer reads offer more coverage of the exons boundaries. Thus, the target read length should be around 100 nucleotides for Illumina RNA-seq to maximize the read overhang length and, consequently, maximize the quality of the alignments. In the Baltica manuscript, we propose an approach to integrate DJU results from Illumina to DJU results from third-generation sequencing. Also, databases such as the CHESS can provide additional evidence for splice sites absent in the annotation.","title":"Tips on RNA-Seq aiming differential splicing detection"},{"location":"proj-config.html","text":"Baltica project configuration: \u00b6 Baltica requires a project configuration file as input. For a template see here . For a programmatic solution to generate the configuration, use the script baltica/write_new_config.R . Method specific parameters are detailed in the Workflow implementation page. Warning Baltica requires a full path to files. Note The Required column flags parameters without default. Parameters description \u00b6 Parameter Description Required path project path \u2713 sample_path path to the parent directory for aligment files \u2713 samples sample name and directory formated as \"{sample_name}: {path_to_sample) \u2713 contrasts list of contrasts names ( format ) \u2713 assembly assembly name on UCSC Browser strandness one of fr-firststrand, fr-secondstrand or none (unstranded) \u2713 read_len maximun read length \u2713 ref path to reference annotation in the GTF format \u2713 ref_fa path to reference annotation in the FASTA format \u2713 project_authors project author name, used in the report project_title project title name, used in file names and report orthognal_result result from Nanopore-seq in GFF or BED with a valida score column, and optionally a comparisons column with contrasts Pairwise comparisons \u00b6 contrasts : { case1 } -vs-{control} : - { case1 } - { control } { cas2 } -vs-{control} : - { case2 } - { control } Note junctionseq and leafcutter support more complex experimental designs, which were not yet implemented in Baltica.","title":"Project configuration"},{"location":"proj-config.html#baltica-project-configuration","text":"Baltica requires a project configuration file as input. For a template see here . For a programmatic solution to generate the configuration, use the script baltica/write_new_config.R . Method specific parameters are detailed in the Workflow implementation page. Warning Baltica requires a full path to files. Note The Required column flags parameters without default.","title":"Baltica project configuration:"},{"location":"proj-config.html#parameters-description","text":"Parameter Description Required path project path \u2713 sample_path path to the parent directory for aligment files \u2713 samples sample name and directory formated as \"{sample_name}: {path_to_sample) \u2713 contrasts list of contrasts names ( format ) \u2713 assembly assembly name on UCSC Browser strandness one of fr-firststrand, fr-secondstrand or none (unstranded) \u2713 read_len maximun read length \u2713 ref path to reference annotation in the GTF format \u2713 ref_fa path to reference annotation in the FASTA format \u2713 project_authors project author name, used in the report project_title project title name, used in file names and report orthognal_result result from Nanopore-seq in GFF or BED with a valida score column, and optionally a comparisons column with contrasts","title":"Parameters description"},{"location":"proj-config.html#pairwise-comparisons","text":"contrasts : { case1 } -vs-{control} : - { case1 } - { control } { cas2 } -vs-{control} : - { case2 } - { control } Note junctionseq and leafcutter support more complex experimental designs, which were not yet implemented in Baltica.","title":"Pairwise comparisons"},{"location":"release-notes.html","text":"Change log \u00b6 Master July 23, 2021 (unreleased) \u00b6 Add rmats workflow Add scrips for parsing for rmats and updated analysis to support the method Create the benchmark with the ONT Nanopore-seq Update benchmaks, included difference comparison for SIRV benchmark Splite annotation and AS type assigment functions Update baltica table algorithm Add support for singularity container via snakemake, with container recipes baltica qc config.yaml --use-singularity Add parsing method for gffcompare tracking output Update configuration file to expose important parameters from the DJU methods Add end-to-end analysis with baltica all config Experiment with meta-score (gradient boosted trees) Add baltica report and improved on report summaries Add orthogonal dataset use-case, to integrate third generation sequencing to the baltica table Change strand parameter to \"fr-firststrand\": \"reverse\", \"fr-secondstrand\": \"forward\" or unstranded, fix error in rmats strand 1.1 September 17, 2020 \u00b6 Add is_novel column, indication introns not into the reference annotation Remove unitended columns (X1, ...) from merge 1.0 - July 23, 2020 \u00b6 First public release comprises of DJU methods Leafcutter, Junctionseq and Majiq. Stringtie for de novo transcriptomics assembly. FastQC and MultiQC (#1).","title":"Release notes"},{"location":"release-notes.html#change-log","text":"","title":"Change log"},{"location":"release-notes.html#master-july-23-2021-unreleased","text":"Add rmats workflow Add scrips for parsing for rmats and updated analysis to support the method Create the benchmark with the ONT Nanopore-seq Update benchmaks, included difference comparison for SIRV benchmark Splite annotation and AS type assigment functions Update baltica table algorithm Add support for singularity container via snakemake, with container recipes baltica qc config.yaml --use-singularity Add parsing method for gffcompare tracking output Update configuration file to expose important parameters from the DJU methods Add end-to-end analysis with baltica all config Experiment with meta-score (gradient boosted trees) Add baltica report and improved on report summaries Add orthogonal dataset use-case, to integrate third generation sequencing to the baltica table Change strand parameter to \"fr-firststrand\": \"reverse\", \"fr-secondstrand\": \"forward\" or unstranded, fix error in rmats strand","title":"Master July 23, 2021 (unreleased)"},{"location":"release-notes.html#11-september-17-2020","text":"Add is_novel column, indication introns not into the reference annotation Remove unitended columns (X1, ...) from merge","title":"1.1  September 17, 2020"},{"location":"release-notes.html#10-july-23-2020","text":"First public release comprises of DJU methods Leafcutter, Junctionseq and Majiq. Stringtie for de novo transcriptomics assembly. FastQC and MultiQC (#1).","title":"1.0 - July 23, 2020"},{"location":"report.html","text":"Report \u00b6","title":"Report"},{"location":"report.html#report","text":"","title":"Report"},{"location":"rmats_notes.html","text":"Installation \u00b6 module load samtools conda create -n rmats \"python==3.6\" cython numpy conda activate rmats git clone https://github.com/Xinglab/rmats-turbo.git cd rmats-turbo # change lines 11, 12 from rMATS_pipeline/setup.py # os.environ['CC'] = '/usr/bin/cc' # os.environ['CXX'] = '/usr/bin/c++' ./build_rmats --no-paired-model > build.log # comment lines, 39, 40 and 52 from test_rmats ./test_rmats # three test will fail # test (tests.paired_stats.test.FilteredEventTest) ... FAIL # test (tests.paired_stats.test.OneEventTest) ... FAIL # test (tests.paired_stats.test.TwoEventTest) ... FAIL Notes on the method \u00b6 For multi gene locus, rMATS may mismatch the origin of the gene with novel AS event https://github.com/Xinglab/rmats-turbo/issues/79#issuecomment-763148314 rMATS only check annotated introns for IR https://github.com/Xinglab/rmats-turbo/issues/65#issuecomment-740722530","title":"Rmats notes"},{"location":"rmats_notes.html#installation","text":"module load samtools conda create -n rmats \"python==3.6\" cython numpy conda activate rmats git clone https://github.com/Xinglab/rmats-turbo.git cd rmats-turbo # change lines 11, 12 from rMATS_pipeline/setup.py # os.environ['CC'] = '/usr/bin/cc' # os.environ['CXX'] = '/usr/bin/c++' ./build_rmats --no-paired-model > build.log # comment lines, 39, 40 and 52 from test_rmats ./test_rmats # three test will fail # test (tests.paired_stats.test.FilteredEventTest) ... FAIL # test (tests.paired_stats.test.OneEventTest) ... FAIL # test (tests.paired_stats.test.TwoEventTest) ... FAIL","title":"Installation"},{"location":"rmats_notes.html#notes-on-the-method","text":"For multi gene locus, rMATS may mismatch the origin of the gene with novel AS event https://github.com/Xinglab/rmats-turbo/issues/79#issuecomment-763148314 rMATS only check annotated introns for IR https://github.com/Xinglab/rmats-turbo/issues/65#issuecomment-740722530","title":"Notes on the method"},{"location":"setup.html","text":"Getting started \u00b6 Quick example: \u00b6 If Baltica dependencies, baltica configuration and cluster configuration are available, use: baltica <workflow> <config> --use-singularity --profile <cluster> workflow : all: run end-to-end wokflows qc: run quality control stringtie: run de novo and guided transcriptome assembly rmats junctionseq majiq leafcutter analysis: run scripts for integration, annotation and reporting config : project configuration file cluster : Snakemake cluster profile Or, read below. Warning Snakemake is under active development. Please contact us if you have any issues with this documentation. Software environment: \u00b6 Baltica framework is based on: - A python command-line interface - Snakemake workflows - Docker containers used with Singularity - R scripts for processing, integrating, annotating, assigning biological features, and reporting - a Rmarkdown report We have developed it on the following computer environments: Linux version 4.19.0-16-amd64 Debian 4.19.181-1 (2021-03-19) gcc version 8.3.0 Python version 3.7.7 Singularity version 3.7.3 Snakemake version 6.4.1 Git version 2.20.1 These versions should not matter because the workflows are run within Docker containers, as long Snakemake version > 6 and a recent Singularity version . Baltica depends on python3, Singulary, and Snakemake. - How to install Singularity - How to install Snakemake Installation \u00b6 git clone https://github.com/dieterich-lab/baltica cd baltica pip install . Will install Baltica and its python dependencies. You may want to create a virtual environment before installing Baltica. All other requirements are resolved with singularity containers. Note We plan to submit Baltica to the Python Package Index. Warning majiq requires an Academic or Commercial license for use. Users are required to obtain their licenses. . Executing Baltica \u00b6 Use baltica cli for current help documentation: baltica --help Baltica executor takes a single optional argument --verbose , to detail it execution. Every other option is passed to Snakemake. Cluster profile \u00b6 Snakemake supports distributed workflow execution in many different high-performance computer clusters, as detailed here . We recommend using cluster profiles and using it like: baltica <workflow> <config> --use-singularity --profile <cluster> (Advanced) Baltica workflows directly from Snakemake \u00b6 Baltica workflows can be used directly with Snakemake without installation. However, there is limited support for it. References \u00b6 If you use Baltica, also please cite Snakemake \u21a9 If you use majiq results, please cite it \u21a9 If you use leafcutter results, please cite it \u21a9 If you use rmats, please cite it \u21a9 If you use junctionseq results, please cite it \u21a9 If you use the Baltica's analysis module, please also cite Stringtie \u21a9","title":"Getting started"},{"location":"setup.html#getting-started","text":"","title":"Getting started"},{"location":"setup.html#quick-example","text":"If Baltica dependencies, baltica configuration and cluster configuration are available, use: baltica <workflow> <config> --use-singularity --profile <cluster> workflow : all: run end-to-end wokflows qc: run quality control stringtie: run de novo and guided transcriptome assembly rmats junctionseq majiq leafcutter analysis: run scripts for integration, annotation and reporting config : project configuration file cluster : Snakemake cluster profile Or, read below. Warning Snakemake is under active development. Please contact us if you have any issues with this documentation.","title":"Quick example:"},{"location":"setup.html#software-environment","text":"Baltica framework is based on: - A python command-line interface - Snakemake workflows - Docker containers used with Singularity - R scripts for processing, integrating, annotating, assigning biological features, and reporting - a Rmarkdown report We have developed it on the following computer environments: Linux version 4.19.0-16-amd64 Debian 4.19.181-1 (2021-03-19) gcc version 8.3.0 Python version 3.7.7 Singularity version 3.7.3 Snakemake version 6.4.1 Git version 2.20.1 These versions should not matter because the workflows are run within Docker containers, as long Snakemake version > 6 and a recent Singularity version . Baltica depends on python3, Singulary, and Snakemake. - How to install Singularity - How to install Snakemake","title":"Software environment:"},{"location":"setup.html#installation","text":"git clone https://github.com/dieterich-lab/baltica cd baltica pip install . Will install Baltica and its python dependencies. You may want to create a virtual environment before installing Baltica. All other requirements are resolved with singularity containers. Note We plan to submit Baltica to the Python Package Index. Warning majiq requires an Academic or Commercial license for use. Users are required to obtain their licenses. .","title":"Installation"},{"location":"setup.html#executing-baltica","text":"Use baltica cli for current help documentation: baltica --help Baltica executor takes a single optional argument --verbose , to detail it execution. Every other option is passed to Snakemake.","title":"Executing Baltica"},{"location":"setup.html#cluster-profile","text":"Snakemake supports distributed workflow execution in many different high-performance computer clusters, as detailed here . We recommend using cluster profiles and using it like: baltica <workflow> <config> --use-singularity --profile <cluster>","title":"Cluster profile"},{"location":"setup.html#advanced-baltica-workflows-directly-from-snakemake","text":"Baltica workflows can be used directly with Snakemake without installation. However, there is limited support for it.","title":"(Advanced) Baltica workflows directly from Snakemake"},{"location":"setup.html#references","text":"If you use Baltica, also please cite Snakemake \u21a9 If you use majiq results, please cite it \u21a9 If you use leafcutter results, please cite it \u21a9 If you use rmats, please cite it \u21a9 If you use junctionseq results, please cite it \u21a9 If you use the Baltica's analysis module, please also cite Stringtie \u21a9","title":"References"},{"location":"tips.html","text":"snakemake takes --dry-run parameter that only computers and then output the list of task to be executed.","title":"Tips"},{"location":"tutorial.html","text":"Step by step tutorial with sample data set \u00b6 We developed and tested the workflows with the Debian Linux distribution (v8.11 Jesse). We use the module system to test the workflows, but conda usage is similar","title":"Tutorial"},{"location":"tutorial.html#step-by-step-tutorial-with-sample-data-set","text":"We developed and tested the workflows with the Debian Linux distribution (v8.11 Jesse). We use the module system to test the workflows, but conda usage is similar","title":"Step by step tutorial with sample data set"},{"location":"workflows.html","text":"Workflow implementation \u00b6 Warning This chapter is partially outdated. This chapter details the implementation and usage of each workflow in Baltica. Baltica comprises a collection of Snakemake workflows (in the SMK format). Each file determines a series of sub-tasks (rules). The sub-tasks run in a specific order; once the output of every rule is complete, the workflow is considered successful. We implemented the workflows following instructions and parameters suggested by the methods authors unless otherwise noted. Fig. 1 - Baltica overview : As input (1), Baltica takes the alignment files in the BAM format, and transcriptome annotation and a configuration file that matches the sample names to the alignment file. The file also holds any workflow parameters. In the first optional step (2), Baltica produces a quality control report with MultiQC, which summarizes the results from FastQC and RSeQC. Next (3), Baltica computes the DJU methods and produces a de novo transcriptome with Stringtie. The novel exons and transcripts are indispensable for the integration step (4). Finally, the framework parses and integrates the output of the DJU methods. Which are achieved by successively calling: Input Quality control: baltica qc <config> Differential Junction Usage (DJU) and de novo transcriptomics: baltica junctionseq <config> baltica majiq <config> baltica leafcutter <config> baltica stringtie <config> Integration: baltica analysis <config> Important The transcriptome annotation is critical, so make sure you use the same annotation during read alignment and Baltica. Note The impact on read alignment on DJU methods results were not fully explored. You should expect different results with different read aligners. We recommend STAR. Method inclusion criteria \u00b6 There are a plethora of DJU methods, defined as methods that model SJ to identify differential splicing. Bellow is the inclusion criteria we used for Baltica. Methods are required to: use as input RNA-Seq read alignment in the BAM format detect AS splicing as changes on SJs level, not at the transcript level provide test statistic that compares a control group to a case group output effect size estimates, such as the deltaPSI detect unannotated SJ We are aware of other methods, such as Suppa 1 and rMATs 2 , also fit these criteria and aim to expand the catalog of supported methods in the future. Quality control workflow \u00b6 The first step comprises the quality control of sequenced libraries and read alignments. This step aims to determine the success of sequencing and alignment. Baltica includes workflows for RSeQC 3 and FastQC. MultiQC 4 summarizes the output from both tools. In addition to the quality control, the tests may suggest biological differences among conditions. For example, RSeQC provides the proportion of reads per feature in the input annotation, which may suggest an enrichment of reads mapping to intronic regions, indicating either intron retention or accumulation of unspliced mRNA. RSeQC also implements an SJ saturation diagnostic, which quantifies the abundance of known and novel SJ. This metric relates to the sequencing depth. This diagnostic is done by sampling subsets of the dataset to identify which proportion of annotated and novel introns are observed in the sub-samples. In conclusion, the quality control step serves to identify potential problems with the RNA-Seq library alignment and, potentially, direct on further troubleshooting and downstream analysis. Software dependencies \u00b6 Name Version RSeQC 2.6.4 FastQC 0.11.8 MultiQC 0.8 DJU workflow \u00b6 In term of implementation, the DJU tools use the following steps: Extracting split reads from the alignment file Defining which SJ or events should be tested Modeling the SJ/events abundance Unfortunately, there are differences among the utilized tools that lead to results that are not trivial to compare. Leafcutter workflow \u00b6 Leafcutter uses a series of scrips to extract the split reads from the BAM files. This step was recently changed to use regtools to speed up the process. Our test shows that this new step affects the workflow results, and so we have not implemented the change in Baltica. Extracting intron from the alignments files: reads with M and N cigar are extracted from the alignments, giving a minimum read overhang Intron clustering: introns with at least minclureads (default: 30) reads and up to maxintronlen kb ( default: 100000) are clustered. The clustering procedure iteratively discards introns supported by less than mincluratio reads within a cluster. Differential splicing analysis: Leafcutter uses a Dirichlet-Multinominal model to model the usage (proportion) of a giving SJ within a cluster and compare this usage among conditions Info By default, Leafcutter clustering does not use the read strandedness information. In Baltica, we override this parameter and use the strand information for clustering. Output \u00b6 The relevant output files from Leafcutter have the _cluster_significance.txt and _effect_sizes.txt suffix, which are computed for each comparison. Column description: *_cluster_significance.txt : 1. cluster : {chromosome}:{intron_start}:{intron_end} 1. Status : is this cluster testable? 1. loglr : the log-likelihood ratio between the null model and alternative 1. df : degrees of freedom, equal to the number of introns in the cluster minus one (assuming two groups) 1. p unadjusted p-value dor the under the asymptotic Chi-squared distribution *_effect_sizes.txt : 1. intron : intron identifier on the format chromosome:intron_start:intron_end:cluster_id 1. es : effect size 1. {cond_1} : fitted junction usage in condition cond_1 1. {cond_2} : fitted junction usage in condition cond_2 1. deltapsi : difference between usage in the two conditions Majiq workflow \u00b6 Majiq workflow is implemented as follows: Create a configuration file ( majiq/build.ini ) Majiq build generates the Splice Graph database with exons and SJ from the RNA-Seq experiment and the reference annotation Majiq deltapsi : - computes PSI and deltaPSI and tests the if the deltaPSI changes between comparisons are significant Voila tsv : filter and process the Majiq output Majiq also provides a visualization with the voila view that we find helpful. Software dependencies \u00b6 Name Version python 3.6 htslib 1.9 Output \u00b6 Baltica parses the files *_voila.tsv (one per comparison). One can read regarding Majiq's output at Majiq's online documentation --> JunctionSeq workflow \u00b6 JunctionSeq 5 tests statistical significance over difference usage among exonic and intronic disjoint genomic bins. It takes as input read count matrix obtained with QoRTs 6 , for annotated SJ, novel SJ, and exons, so in fact, JunctionSeq fits both the DEU and DJU classifications. Bins selected are testable as modeled with generalized linear models, as described in DEXSeq 7 , but reporting a test statistic at the genomic feature (exon or junction) and gene level. Different from other DJU methods, JunctionSeq does not group the SJ in AS events, and so it does not compute PSI events. By default, SJ with p.adjust < 0.05 are called significant. Software dependencies \u00b6 Name Version R 3.6 qorts 1.1.8 Qorts depends on Java. We currently use it with Java 11.0.6. JunctionSeq itself relies on a series of BioConductor packages. Output \u00b6 Baltica parses files with the *_sigGenes.results.txt.gz suffix (one per comparison). Detailed output information are in the JunctionSeq Package User Manual Stringtie workflow \u00b6 Baltica uses splice graph information to reconcile the SJ coordinates among methods and to assign AS type. We process de novo transcriptomic workflow with Stringtie [@pertea_2015]. First, we merge the alignment files from biological replicates. Next, we compute de novo annotation with Stringtie (v1.3.5) with -c 3 , -j 3 , and -f 0.01 . Finally, the merge the multiple annotation with gffcompare -r {reference_annotation.gtf} -R -V . Details on the parameter selection are in the Integration chapter . Software dependencies \u00b6 Name Version Stringtie 1.3.5 Parameters \u00b6 Rule Name Default Note denovo_transcriptomics strandness reverse denovo_transcriptomics min_isoform_proportion 0.001 denovo_transcriptomics min_junct_coverage 3 denovo_transcriptomics minimum_read_per_bp_coverage 3 Juan L. Trincado, Juan C. Entizne, Gerald Hysenaj, Babita Singh, Miha Skalic, David J. Elliott, and Eduardo Eyras. SUPPA2: fast, accurate, and uncertainty-aware differential splicing analysis across multiple conditions. Genome Biology , March 2018. URL: https://doi.org/10.1186/s13059-018-1417-1 , doi:10.1186/s13059-018-1417-1 . \u21a9 Shihao Shen, Juw Won Park, Zhi-xiang Lu, Lan Lin, Michael D. Henry, Ying Nian Wu, Qing Zhou, and Yi Xing. Rmats: robust and flexible detection of differential alternative splicing from replicate rna-seq data. Proceedings of the National Academy of Sciences , 111(51):E5593\u2013E5601, Dec 2014. URL: http://dx.doi.org/10.1073/pnas.1419161111 , doi:10.1073/pnas.1419161111 . \u21a9 Liguo Wang, Shengqin Wang, and Wei Li. RSeQC: quality control of RNA-seq experiments. Bioinformatics , 28(16):2184\u20132185, June 2012. URL: https://doi.org/10.1093/bioinformatics/bts356 , doi:10.1093/bioinformatics/bts356 . \u21a9 Philip Ewels, M\u00e5ns Magnusson, Sverker Lundin, and Max K\u00e4ller. Multiqc: summarize analysis results for multiple tools and samples in a single report. Bioinformatics , 32(19):3047\u20133048, Jun 2016. URL: http://dx.doi.org/10.1093/bioinformatics/btw354 , doi:10.1093/bioinformatics/btw354 . \u21a9 Stephen W. Hartley and James C. Mullikin. Detection and visualization of differential splicing in RNA-seq data with JunctionSeq. Nucleic Acids Research , pages gkw501, June 2016. URL: https://doi.org/10.1093/nar/gkw501 , doi:10.1093/nar/gkw501 . \u21a9 Stephen W. Hartley and James C. Mullikin. Qorts: a comprehensive toolset for quality control and data processing of rna-seq experiments. BMC Bioinformatics , Jul 2015. URL: http://dx.doi.org/10.1186/s12859-015-0670-5 , doi:10.1186/s12859-015-0670-5 . \u21a9 S. Anders, A. Reyes, and W. Huber. Detecting differential usage of exons from RNA-seq data. Genome Research , 22(10):2008\u20132017, June 2012. URL: https://doi.org/10.1101/gr.133744.111 , doi:10.1101/gr.133744.111 . \u21a9","title":"Workflow implementation"},{"location":"workflows.html#workflow-implementation","text":"Warning This chapter is partially outdated. This chapter details the implementation and usage of each workflow in Baltica. Baltica comprises a collection of Snakemake workflows (in the SMK format). Each file determines a series of sub-tasks (rules). The sub-tasks run in a specific order; once the output of every rule is complete, the workflow is considered successful. We implemented the workflows following instructions and parameters suggested by the methods authors unless otherwise noted. Fig. 1 - Baltica overview : As input (1), Baltica takes the alignment files in the BAM format, and transcriptome annotation and a configuration file that matches the sample names to the alignment file. The file also holds any workflow parameters. In the first optional step (2), Baltica produces a quality control report with MultiQC, which summarizes the results from FastQC and RSeQC. Next (3), Baltica computes the DJU methods and produces a de novo transcriptome with Stringtie. The novel exons and transcripts are indispensable for the integration step (4). Finally, the framework parses and integrates the output of the DJU methods. Which are achieved by successively calling: Input Quality control: baltica qc <config> Differential Junction Usage (DJU) and de novo transcriptomics: baltica junctionseq <config> baltica majiq <config> baltica leafcutter <config> baltica stringtie <config> Integration: baltica analysis <config> Important The transcriptome annotation is critical, so make sure you use the same annotation during read alignment and Baltica. Note The impact on read alignment on DJU methods results were not fully explored. You should expect different results with different read aligners. We recommend STAR.","title":"Workflow implementation"},{"location":"workflows.html#method-inclusion-criteria","text":"There are a plethora of DJU methods, defined as methods that model SJ to identify differential splicing. Bellow is the inclusion criteria we used for Baltica. Methods are required to: use as input RNA-Seq read alignment in the BAM format detect AS splicing as changes on SJs level, not at the transcript level provide test statistic that compares a control group to a case group output effect size estimates, such as the deltaPSI detect unannotated SJ We are aware of other methods, such as Suppa 1 and rMATs 2 , also fit these criteria and aim to expand the catalog of supported methods in the future.","title":"Method inclusion criteria"},{"location":"workflows.html#quality-control-workflow","text":"The first step comprises the quality control of sequenced libraries and read alignments. This step aims to determine the success of sequencing and alignment. Baltica includes workflows for RSeQC 3 and FastQC. MultiQC 4 summarizes the output from both tools. In addition to the quality control, the tests may suggest biological differences among conditions. For example, RSeQC provides the proportion of reads per feature in the input annotation, which may suggest an enrichment of reads mapping to intronic regions, indicating either intron retention or accumulation of unspliced mRNA. RSeQC also implements an SJ saturation diagnostic, which quantifies the abundance of known and novel SJ. This metric relates to the sequencing depth. This diagnostic is done by sampling subsets of the dataset to identify which proportion of annotated and novel introns are observed in the sub-samples. In conclusion, the quality control step serves to identify potential problems with the RNA-Seq library alignment and, potentially, direct on further troubleshooting and downstream analysis.","title":"Quality control workflow"},{"location":"workflows.html#software-dependencies","text":"Name Version RSeQC 2.6.4 FastQC 0.11.8 MultiQC 0.8","title":"Software dependencies"},{"location":"workflows.html#dju-workflow","text":"In term of implementation, the DJU tools use the following steps: Extracting split reads from the alignment file Defining which SJ or events should be tested Modeling the SJ/events abundance Unfortunately, there are differences among the utilized tools that lead to results that are not trivial to compare.","title":"DJU workflow"},{"location":"workflows.html#leafcutter-workflow","text":"Leafcutter uses a series of scrips to extract the split reads from the BAM files. This step was recently changed to use regtools to speed up the process. Our test shows that this new step affects the workflow results, and so we have not implemented the change in Baltica. Extracting intron from the alignments files: reads with M and N cigar are extracted from the alignments, giving a minimum read overhang Intron clustering: introns with at least minclureads (default: 30) reads and up to maxintronlen kb ( default: 100000) are clustered. The clustering procedure iteratively discards introns supported by less than mincluratio reads within a cluster. Differential splicing analysis: Leafcutter uses a Dirichlet-Multinominal model to model the usage (proportion) of a giving SJ within a cluster and compare this usage among conditions Info By default, Leafcutter clustering does not use the read strandedness information. In Baltica, we override this parameter and use the strand information for clustering.","title":"Leafcutter workflow"},{"location":"workflows.html#output","text":"The relevant output files from Leafcutter have the _cluster_significance.txt and _effect_sizes.txt suffix, which are computed for each comparison. Column description: *_cluster_significance.txt : 1. cluster : {chromosome}:{intron_start}:{intron_end} 1. Status : is this cluster testable? 1. loglr : the log-likelihood ratio between the null model and alternative 1. df : degrees of freedom, equal to the number of introns in the cluster minus one (assuming two groups) 1. p unadjusted p-value dor the under the asymptotic Chi-squared distribution *_effect_sizes.txt : 1. intron : intron identifier on the format chromosome:intron_start:intron_end:cluster_id 1. es : effect size 1. {cond_1} : fitted junction usage in condition cond_1 1. {cond_2} : fitted junction usage in condition cond_2 1. deltapsi : difference between usage in the two conditions","title":"Output"},{"location":"workflows.html#majiq-workflow","text":"Majiq workflow is implemented as follows: Create a configuration file ( majiq/build.ini ) Majiq build generates the Splice Graph database with exons and SJ from the RNA-Seq experiment and the reference annotation Majiq deltapsi : - computes PSI and deltaPSI and tests the if the deltaPSI changes between comparisons are significant Voila tsv : filter and process the Majiq output Majiq also provides a visualization with the voila view that we find helpful.","title":"Majiq workflow"},{"location":"workflows.html#software-dependencies_1","text":"Name Version python 3.6 htslib 1.9","title":"Software dependencies"},{"location":"workflows.html#output_1","text":"Baltica parses the files *_voila.tsv (one per comparison). One can read regarding Majiq's output at Majiq's online documentation -->","title":"Output"},{"location":"workflows.html#junctionseq-workflow","text":"JunctionSeq 5 tests statistical significance over difference usage among exonic and intronic disjoint genomic bins. It takes as input read count matrix obtained with QoRTs 6 , for annotated SJ, novel SJ, and exons, so in fact, JunctionSeq fits both the DEU and DJU classifications. Bins selected are testable as modeled with generalized linear models, as described in DEXSeq 7 , but reporting a test statistic at the genomic feature (exon or junction) and gene level. Different from other DJU methods, JunctionSeq does not group the SJ in AS events, and so it does not compute PSI events. By default, SJ with p.adjust < 0.05 are called significant.","title":"JunctionSeq workflow"},{"location":"workflows.html#software-dependencies_2","text":"Name Version R 3.6 qorts 1.1.8 Qorts depends on Java. We currently use it with Java 11.0.6. JunctionSeq itself relies on a series of BioConductor packages.","title":"Software dependencies"},{"location":"workflows.html#output_2","text":"Baltica parses files with the *_sigGenes.results.txt.gz suffix (one per comparison). Detailed output information are in the JunctionSeq Package User Manual","title":"Output"},{"location":"workflows.html#stringtie-workflow","text":"Baltica uses splice graph information to reconcile the SJ coordinates among methods and to assign AS type. We process de novo transcriptomic workflow with Stringtie [@pertea_2015]. First, we merge the alignment files from biological replicates. Next, we compute de novo annotation with Stringtie (v1.3.5) with -c 3 , -j 3 , and -f 0.01 . Finally, the merge the multiple annotation with gffcompare -r {reference_annotation.gtf} -R -V . Details on the parameter selection are in the Integration chapter .","title":"Stringtie workflow"},{"location":"workflows.html#software-dependencies_3","text":"Name Version Stringtie 1.3.5","title":"Software dependencies"},{"location":"workflows.html#parameters","text":"Rule Name Default Note denovo_transcriptomics strandness reverse denovo_transcriptomics min_isoform_proportion 0.001 denovo_transcriptomics min_junct_coverage 3 denovo_transcriptomics minimum_read_per_bp_coverage 3 Juan L. Trincado, Juan C. Entizne, Gerald Hysenaj, Babita Singh, Miha Skalic, David J. Elliott, and Eduardo Eyras. SUPPA2: fast, accurate, and uncertainty-aware differential splicing analysis across multiple conditions. Genome Biology , March 2018. URL: https://doi.org/10.1186/s13059-018-1417-1 , doi:10.1186/s13059-018-1417-1 . \u21a9 Shihao Shen, Juw Won Park, Zhi-xiang Lu, Lan Lin, Michael D. Henry, Ying Nian Wu, Qing Zhou, and Yi Xing. Rmats: robust and flexible detection of differential alternative splicing from replicate rna-seq data. Proceedings of the National Academy of Sciences , 111(51):E5593\u2013E5601, Dec 2014. URL: http://dx.doi.org/10.1073/pnas.1419161111 , doi:10.1073/pnas.1419161111 . \u21a9 Liguo Wang, Shengqin Wang, and Wei Li. RSeQC: quality control of RNA-seq experiments. Bioinformatics , 28(16):2184\u20132185, June 2012. URL: https://doi.org/10.1093/bioinformatics/bts356 , doi:10.1093/bioinformatics/bts356 . \u21a9 Philip Ewels, M\u00e5ns Magnusson, Sverker Lundin, and Max K\u00e4ller. Multiqc: summarize analysis results for multiple tools and samples in a single report. Bioinformatics , 32(19):3047\u20133048, Jun 2016. URL: http://dx.doi.org/10.1093/bioinformatics/btw354 , doi:10.1093/bioinformatics/btw354 . \u21a9 Stephen W. Hartley and James C. Mullikin. Detection and visualization of differential splicing in RNA-seq data with JunctionSeq. Nucleic Acids Research , pages gkw501, June 2016. URL: https://doi.org/10.1093/nar/gkw501 , doi:10.1093/nar/gkw501 . \u21a9 Stephen W. Hartley and James C. Mullikin. Qorts: a comprehensive toolset for quality control and data processing of rna-seq experiments. BMC Bioinformatics , Jul 2015. URL: http://dx.doi.org/10.1186/s12859-015-0670-5 , doi:10.1186/s12859-015-0670-5 . \u21a9 S. Anders, A. Reyes, and W. Huber. Detecting differential usage of exons from RNA-seq data. Genome Research , 22(10):2008\u20132017, June 2012. URL: https://doi.org/10.1101/gr.133744.111 , doi:10.1101/gr.133744.111 . \u21a9","title":"Parameters"}]}