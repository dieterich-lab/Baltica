{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Baltica: integrated splice junction usage analysis \u00b6 Baltica is a framework that facilitates the execution and enables the integration of results from multiple differential junction usage (DJU) methods. The core of the framework is Snakemake workflows 1 , a python command-line interface, and R/Bioconductor scripts for analysis 2 3 4 5 . The workflows are include methods for RNA-Seq quality control 6 7 8 , four DJU methods: RMATs 9 JunctionSeq 10 , Majiq 11 and Leafcutter 12 . We use Stringtie2 13 de novo transcriptome assembly to re-annotate the results. Baltica's main goal is to provide an integrative view of the results of these methods. To do so, Baltica produces an RMarkdown report with the integrated results and links to UCSC GenomeBrowser for further exploration. Features \u00b6 - Snakemake workflows for DJU: junctionseq, majiq, rmats, and leafcutter - Snakemake workflow for de novo transcriptome annotation with stringtie - Process, integrate and annotate the results from the methods - Summarise AS class of differently spliced junctions - DJU method benchmarks - Report on the integrative analysis To get started , use the menu on the left-hand side or search function to navigate over this documentation. Citation \u00b6 Britto-Borges T, Boehm V, Gehring NH, Dieterich C. Baltica: integrated splice junction usage analysis. bioRxiv. 2021 Jan 1. doi: https://doi.org/10.1101/2021.12.23.473966 Baltica is based on the work of many scientists and developers. Thus, if you use the results of their tools in your analysis, consider citing their work. License \u00b6 Baltica is free, open-source software released under an MIT License . Contact \u00b6 Please get in touch with us the GitHub issue tracker . References \u00b6 Felix M\u00f6lder, Kim Philipp Jablonski, Brice Letcher, Michael B. Hall, Christopher H. Tomkins-Tinch, Vanessa Sochat, Jan Forster, Soohyun Lee, Sven O. Twardziok, Alexander Kanitz, and et al. Sustainable data analysis with snakemake. F1000Research , 10:33, Apr 2021. URL: http://dx.doi.org/10.12688/f1000research.29032.2 , doi:10.12688/f1000research.29032.2 . \u21a9 R Core Team. R: A Language and Environment for Statistical Computing . R Foundation for Statistical Computing, Vienna, Austria, 2021. URL: https://www.R-project.org/ . \u21a9 Michael Lawrence, Wolfgang Huber, Herv\u00e9 Pag\u00e8s, Patrick Aboyoun, Marc Carlson, Robert Gentleman, Martin T. Morgan, and Vincent J. Carey. Software for computing and annotating genomic ranges. PLoS Computational Biology , 9(8):e1003118, Aug 2013. URL: http://dx.doi.org/10.1371/journal.pcbi.1003118 , doi:10.1371/journal.pcbi.1003118 . \u21a9 M. Lawrence, R. Gentleman, and V. Carey. Rtracklayer: an r package for interfacing with genome browsers. Bioinformatics , 25(14):1841\u20131842, May 2009. URL: http://dx.doi.org/10.1093/bioinformatics/btp328 , doi:10.1093/bioinformatics/btp328 . \u21a9 Hadley Wickham, Mara Averick, Jennifer Bryan, Winston Chang, Lucy McGowan, Romain Fran\u00e7ois, Garrett Grolemund, Alex Hayes, Lionel Henry, Jim Hester, and et al. Welcome to the tidyverse. Journal of Open Source Software , 4(43):1686, Nov 2019. URL: http://dx.doi.org/10.21105/joss.01686 , doi:10.21105/joss.01686 . \u21a9 Liguo Wang, Shengqin Wang, and Wei Li. RSeQC: quality control of RNA-seq experiments. Bioinformatics , 28(16):2184\u20132185, June 2012. URL: https://doi.org/10.1093/bioinformatics/bts356 , doi:10.1093/bioinformatics/bts356 . \u21a9 Simon Andrews, Felix Krueger, Anne Segonds-Pichon, Laura Biggins, Christel Krueger, and Steven Wingett. FastQC. Babraham Institute, January 2012. URL: https://qubeshub.org/resources/fastqc . \u21a9 Philip Ewels, M\u00e5ns Magnusson, Sverker Lundin, and Max K\u00e4ller. MultiQC: summarize analysis results for multiple tools and samples in a single report. Bioinformatics , 32(19):3047\u20133048, Jun 2016. URL: http://dx.doi.org/10.1093/bioinformatics/btw354 , doi:10.1093/bioinformatics/btw354 . \u21a9 Shihao Shen, Juw Won Park, Zhi-xiang Lu, Lan Lin, Michael D. Henry, Ying Nian Wu, Qing Zhou, and Yi Xing. Rmats: robust and flexible detection of differential alternative splicing from replicate rna-seq data. Proceedings of the National Academy of Sciences , 111(51):E5593\u2013E5601, Dec 2014. URL: http://dx.doi.org/10.1073/pnas.1419161111 , doi:10.1073/pnas.1419161111 . \u21a9 Stephen W. Hartley and James C. Mullikin. Detection and visualization of differential splicing in RNA-seq data with JunctionSeq. Nucleic Acids Research , pages gkw501, June 2016. URL: https://doi.org/10.1093/nar/gkw501 , doi:10.1093/nar/gkw501 . \u21a9 Jorge Vaquero-Garcia, Alejandro Barrera, Matthew R Gazzara, Juan Gonzalez-Vallinas, Nicholas F Lahens, John B Hogenesch, Kristen W Lynch, and Yoseph Barash. A new view of transcriptome complexity and regulation through the lens of local splicing variations. eLife , February 2016. URL: https://doi.org/10.7554/elife.11752 , doi:10.7554/elife.11752 . \u21a9 Yang I. Li, David A. Knowles, Jack Humphrey, Alvaro N. Barbeira, Scott P. Dickinson, Hae Kyung Im, and Jonathan K. Pritchard. Annotation-free quantification of RNA splicing using LeafCutter. Nature Genetics , 50(1):151\u2013158, December 2017. URL: https://doi.org/10.1038/s41588-017-0004-9 , doi:10.1038/s41588-017-0004-9 . \u21a9 Sam Kovaka, Aleksey V. Zimin, Geo M. Pertea, Roham Razaghi, Steven L. Salzberg, and Mihaela Pertea. Transcriptome assembly from long-read rna-seq alignments with stringtie2. Genome Biology , Dec 2019. URL: http://dx.doi.org/10.1186/s13059-019-1910-1 , doi:10.1186/s13059-019-1910-1 . \u21a9","title":"Index"},{"location":"index.html#baltica-integrated-splice-junction-usage-analysis","text":"Baltica is a framework that facilitates the execution and enables the integration of results from multiple differential junction usage (DJU) methods. The core of the framework is Snakemake workflows 1 , a python command-line interface, and R/Bioconductor scripts for analysis 2 3 4 5 . The workflows are include methods for RNA-Seq quality control 6 7 8 , four DJU methods: RMATs 9 JunctionSeq 10 , Majiq 11 and Leafcutter 12 . We use Stringtie2 13 de novo transcriptome assembly to re-annotate the results. Baltica's main goal is to provide an integrative view of the results of these methods. To do so, Baltica produces an RMarkdown report with the integrated results and links to UCSC GenomeBrowser for further exploration.","title":"Baltica: integrated splice junction usage analysis"},{"location":"index.html#features","text":"- Snakemake workflows for DJU: junctionseq, majiq, rmats, and leafcutter - Snakemake workflow for de novo transcriptome annotation with stringtie - Process, integrate and annotate the results from the methods - Summarise AS class of differently spliced junctions - DJU method benchmarks - Report on the integrative analysis To get started , use the menu on the left-hand side or search function to navigate over this documentation.","title":"Features"},{"location":"index.html#citation","text":"Britto-Borges T, Boehm V, Gehring NH, Dieterich C. Baltica: integrated splice junction usage analysis. bioRxiv. 2021 Jan 1. doi: https://doi.org/10.1101/2021.12.23.473966 Baltica is based on the work of many scientists and developers. Thus, if you use the results of their tools in your analysis, consider citing their work.","title":"Citation"},{"location":"index.html#license","text":"Baltica is free, open-source software released under an MIT License .","title":"License"},{"location":"index.html#contact","text":"Please get in touch with us the GitHub issue tracker .","title":"Contact"},{"location":"index.html#references","text":"Felix M\u00f6lder, Kim Philipp Jablonski, Brice Letcher, Michael B. Hall, Christopher H. Tomkins-Tinch, Vanessa Sochat, Jan Forster, Soohyun Lee, Sven O. Twardziok, Alexander Kanitz, and et al. Sustainable data analysis with snakemake. F1000Research , 10:33, Apr 2021. URL: http://dx.doi.org/10.12688/f1000research.29032.2 , doi:10.12688/f1000research.29032.2 . \u21a9 R Core Team. R: A Language and Environment for Statistical Computing . R Foundation for Statistical Computing, Vienna, Austria, 2021. URL: https://www.R-project.org/ . \u21a9 Michael Lawrence, Wolfgang Huber, Herv\u00e9 Pag\u00e8s, Patrick Aboyoun, Marc Carlson, Robert Gentleman, Martin T. Morgan, and Vincent J. Carey. Software for computing and annotating genomic ranges. PLoS Computational Biology , 9(8):e1003118, Aug 2013. URL: http://dx.doi.org/10.1371/journal.pcbi.1003118 , doi:10.1371/journal.pcbi.1003118 . \u21a9 M. Lawrence, R. Gentleman, and V. Carey. Rtracklayer: an r package for interfacing with genome browsers. Bioinformatics , 25(14):1841\u20131842, May 2009. URL: http://dx.doi.org/10.1093/bioinformatics/btp328 , doi:10.1093/bioinformatics/btp328 . \u21a9 Hadley Wickham, Mara Averick, Jennifer Bryan, Winston Chang, Lucy McGowan, Romain Fran\u00e7ois, Garrett Grolemund, Alex Hayes, Lionel Henry, Jim Hester, and et al. Welcome to the tidyverse. Journal of Open Source Software , 4(43):1686, Nov 2019. URL: http://dx.doi.org/10.21105/joss.01686 , doi:10.21105/joss.01686 . \u21a9 Liguo Wang, Shengqin Wang, and Wei Li. RSeQC: quality control of RNA-seq experiments. Bioinformatics , 28(16):2184\u20132185, June 2012. URL: https://doi.org/10.1093/bioinformatics/bts356 , doi:10.1093/bioinformatics/bts356 . \u21a9 Simon Andrews, Felix Krueger, Anne Segonds-Pichon, Laura Biggins, Christel Krueger, and Steven Wingett. FastQC. Babraham Institute, January 2012. URL: https://qubeshub.org/resources/fastqc . \u21a9 Philip Ewels, M\u00e5ns Magnusson, Sverker Lundin, and Max K\u00e4ller. MultiQC: summarize analysis results for multiple tools and samples in a single report. Bioinformatics , 32(19):3047\u20133048, Jun 2016. URL: http://dx.doi.org/10.1093/bioinformatics/btw354 , doi:10.1093/bioinformatics/btw354 . \u21a9 Shihao Shen, Juw Won Park, Zhi-xiang Lu, Lan Lin, Michael D. Henry, Ying Nian Wu, Qing Zhou, and Yi Xing. Rmats: robust and flexible detection of differential alternative splicing from replicate rna-seq data. Proceedings of the National Academy of Sciences , 111(51):E5593\u2013E5601, Dec 2014. URL: http://dx.doi.org/10.1073/pnas.1419161111 , doi:10.1073/pnas.1419161111 . \u21a9 Stephen W. Hartley and James C. Mullikin. Detection and visualization of differential splicing in RNA-seq data with JunctionSeq. Nucleic Acids Research , pages gkw501, June 2016. URL: https://doi.org/10.1093/nar/gkw501 , doi:10.1093/nar/gkw501 . \u21a9 Jorge Vaquero-Garcia, Alejandro Barrera, Matthew R Gazzara, Juan Gonzalez-Vallinas, Nicholas F Lahens, John B Hogenesch, Kristen W Lynch, and Yoseph Barash. A new view of transcriptome complexity and regulation through the lens of local splicing variations. eLife , February 2016. URL: https://doi.org/10.7554/elife.11752 , doi:10.7554/elife.11752 . \u21a9 Yang I. Li, David A. Knowles, Jack Humphrey, Alvaro N. Barbeira, Scott P. Dickinson, Hae Kyung Im, and Jonathan K. Pritchard. Annotation-free quantification of RNA splicing using LeafCutter. Nature Genetics , 50(1):151\u2013158, December 2017. URL: https://doi.org/10.1038/s41588-017-0004-9 , doi:10.1038/s41588-017-0004-9 . \u21a9 Sam Kovaka, Aleksey V. Zimin, Geo M. Pertea, Roham Razaghi, Steven L. Salzberg, and Mihaela Pertea. Transcriptome assembly from long-read rna-seq alignments with stringtie2. Genome Biology , Dec 2019. URL: http://dx.doi.org/10.1186/s13059-019-1910-1 , doi:10.1186/s13059-019-1910-1 . \u21a9","title":"References"},{"location":"analysis.html","text":"AA \u00b6 Result files are parsed and transformed to tidy format: - each row presents a junction and pair-wise comparison at a first moment, we don't filter any results based on the probability of obtaining the observed results of a test, giving a null hypothesis is true (p-value) or effect size change (deltaPSI). This is done in a second step with files with 'annotated' Difference in interpretation among the tools: Analysis design For Junctionseq model include all conditions at once Majiq pairwise, Leafcutter currently pairwise, although it also supports more complex design As result, SJ from JunctionSeq have single p-value, while multiple Arbitrary cutoffs: - Majiq: xx == 1 & deltapsi - Leafcutter: padj < 0.05 - JunctionSeq:","title":"AA"},{"location":"analysis.html#aa","text":"Result files are parsed and transformed to tidy format: - each row presents a junction and pair-wise comparison at a first moment, we don't filter any results based on the probability of obtaining the observed results of a test, giving a null hypothesis is true (p-value) or effect size change (deltaPSI). This is done in a second step with files with 'annotated' Difference in interpretation among the tools: Analysis design For Junctionseq model include all conditions at once Majiq pairwise, Leafcutter currently pairwise, although it also supports more complex design As result, SJ from JunctionSeq have single p-value, while multiple Arbitrary cutoffs: - Majiq: xx == 1 & deltapsi - Leafcutter: padj < 0.05 - JunctionSeq:","title":"AA"},{"location":"benchmark.html","text":"We implemented a benchmark method for DJU methods using the Spike-In RNA Variants (SIRVs Set-1, cat 025.03 1 ) as ground-truth for alternative splicing identification. Differential splicing methods often use simulated data for benchmark, which does not fully appreciate the complexity of RNA-Sequencing experiment. We use a complementary approach that aims to overcome this limitation. The SIRVs spike-in comprise seven genes, 69 transcript isoforms, 357 exons and 113 intron According to our experimental design ( Fig. 5.1 ), differences in transcript abundance lead to differential splicing events in SIRV chromosomes but not in the human contigs, which would represent false-positive calls. To benchmark the dataset, we use Baltica to run the three tools comparing three groups: - mix 2 versus mix 1 - mix 3 versus mix 2 - mix 3 versus mix 1 Important The test data currently shipping with Baltica has only a subset of 10% of the reads per group in Gerbracht et al. 2020 ( E-MTAB-8461 ). Fig. 5.1: Experimental design : The first column represents the experimental groups. See 2 for detail on the biological differences among groups. The second column represents the SIRV mixes. The third column is the sample id from the sequencing facility. RNA-Seq processing and mapping \u00b6 Cell lines, RNA extraction, and RNA-Seq were described by 2 . In short, we obtained 15 libraries from Flp-In T-REx 293 cells, extracted the RNA fraction, with TrueSeq Stranded Total RNA kit (Illumina), followed by ribosomal RNA depletion, with RiboGold Plus kit. Reads were sequenced with an Illumina HiSeq4000 sequencer using PE 100bp protocol and yield around 50 million reads per sample. Data is deposited in ArrayExpress (E-MTAB-8461). Sequenced reads' adapters and low-quality bases were trimmed, and reads mapping to human precursor ribosomal RNA were discarded. The remaining reads were aligned to the human transcriptome (version 38, EnsEMBL 90) extended with the SIRV annotation. Regarding the DJU method benchmarking, we are not interested in the biological condition, but the SIRVs AS event, and so this experiment was designed, so the SIRVs mixes were not confounded to the biological factors. DJU method produces results with little agreement \u00b6 To demonstrated the previously observed lack of consensus among DJU methods, we computed DJU with JunctionSeq, Majiq, and Leafcutter with the SIRVs, for three mixes containing a variable abundance of each transcript. The difference abundances are equivalent to differences in junction usage. The mixes were incorporated into the RNA-Seq experiment in non-confounded design with the biological co-variates, so the SJ observed in the natural contigs (human chromosome) could be used as false-positive calls. Table 5.1 shows the number of SJ identified and called significant ( see the Workflow Chapter for detains on how the we reconcile these results). Majiq and JunctionSeq call around 310 significant SJ, while Leafcutter calls 201. Overall, the methods produce a comparable number of SJ called significant. - Junctionseq Majiq Leafcutter Total 608 2850 131676 Significant 311 309 201 Table 5.1 : Number of SJ considered (Total) and called significant (Significant) for each method. However, when comparing the resulting gene and SJ sets, we observe a limited intersection among the results from the three methods ( Fig. 5.2 ) for genes and SJ. To further understand this issue, we reviewed the step-by-step process implemented by the methods. Overall, the three DJU methods share three steps, as mentioned before: Reads are extracted and filtered from the read alignments. Testable SJ or splicing events are identified, for example, by clustering. The SJ or splicing events counts are modelled. Fig. 5.2: Overlap between genes and SJ called significant by three DJU methods. JunctionSeq, Majiq and, Leafcutter deliver results that show a limited agreement among each other. We computed differential junction usage using the three methods on 15 RNA-Seq libraries with 3 groups, the three SIRV mixes. The resulting intersection shows that only small overlap genes ( A ) and SJ ( B ) called significant by the tools 9% (6 out of 66) and 16% (34 out of 212), respectively. Benchmark \u00b6 We extracted all introns from the SIRV transcripts and classified between diff (changing between mixes) and no diff. Given the binary outcome from each tool, we analysed the following cases: True positive: diff intron called significant False-positive: no diff intron or intron in human contig called significant True negative: no diff not called significant False-negative: diff intron not called significant Results from the methods benchmark \u00b6 TN FP FN TP Majiq 2492 126 90 82 JunctionSeq 273 43 24 268 Leafcutter 131474 43 1 158 Table 5.2: Methods and number of SJ in each classification case Junctionseq achieves the highest number of TP calls and Junctionseq and Leafcutter the lowest number of FP calls. Based on that procedure, we proceeded with a two-class validation and computed the Receiver Operating Characteristic (ROC) curve and the precision-recall curve. Fig 5.3 ROC and Precision-recall curve : we observe the in this benchmark JunctionSeq outperforms Majiq and Leafcutter. The curves shows that Junctionseq outperforms the other two methods in the conditions we have analysed. Despite the punctual similarities, the implementation of these three state-of-art methods vary. Here we present a direct comparison on a set of artificial transcripts. The cumulative differences in who to define which SJ are extracted and tested; how much the method relies on the annotation; and the framework for statistical modelling explain the small intersections in Fig. 5.2 . In this case, Leafcutter suffers from a recall ceiling issue, because it ignores certain introns from the artificial transcripts. JunctionSeq has a clear advantage in this comparison because it relies heavily on the information of the annotation and the input annotation, that in this case, perfectly represents the structure of the transcripts. Majiq suffers from an excess of false-positive calls. Baltica aims to further study these implementations differences and potentially suggestion advice to minimize the effect of the limitations mentioned above. https://www.lexogen.com/sirvs/#sirvsdownload - Lexogen took no part in the experimental design neither we have any relationship with the company. \u21a9 Jennifer V Gerbracht, Volker Boehm, Thiago Britto-Borges, Sebastian Kallabis, Janica L Wiederstein, Simona Ciriello, Dominik U Aschemeier, Marcus Kr\u00fcger, Christian K Frese, Janine Altm\u00fcller, and et al. Casc3 promotes transcriptome-wide activation of nonsense-mediated decay by the exon junction complex. Nucleic Acids Research , 48(15):8626\u20138644, Jul 2020. URL: http://dx.doi.org/10.1093/nar/gkaa564 , doi:10.1093/nar/gkaa564 . \u21a9 \u21a9","title":"Benchmark"},{"location":"benchmark.html#rna-seq-processing-and-mapping","text":"Cell lines, RNA extraction, and RNA-Seq were described by 2 . In short, we obtained 15 libraries from Flp-In T-REx 293 cells, extracted the RNA fraction, with TrueSeq Stranded Total RNA kit (Illumina), followed by ribosomal RNA depletion, with RiboGold Plus kit. Reads were sequenced with an Illumina HiSeq4000 sequencer using PE 100bp protocol and yield around 50 million reads per sample. Data is deposited in ArrayExpress (E-MTAB-8461). Sequenced reads' adapters and low-quality bases were trimmed, and reads mapping to human precursor ribosomal RNA were discarded. The remaining reads were aligned to the human transcriptome (version 38, EnsEMBL 90) extended with the SIRV annotation. Regarding the DJU method benchmarking, we are not interested in the biological condition, but the SIRVs AS event, and so this experiment was designed, so the SIRVs mixes were not confounded to the biological factors.","title":"RNA-Seq processing and mapping"},{"location":"benchmark.html#dju-method-produces-results-with-little-agreement","text":"To demonstrated the previously observed lack of consensus among DJU methods, we computed DJU with JunctionSeq, Majiq, and Leafcutter with the SIRVs, for three mixes containing a variable abundance of each transcript. The difference abundances are equivalent to differences in junction usage. The mixes were incorporated into the RNA-Seq experiment in non-confounded design with the biological co-variates, so the SJ observed in the natural contigs (human chromosome) could be used as false-positive calls. Table 5.1 shows the number of SJ identified and called significant ( see the Workflow Chapter for detains on how the we reconcile these results). Majiq and JunctionSeq call around 310 significant SJ, while Leafcutter calls 201. Overall, the methods produce a comparable number of SJ called significant. - Junctionseq Majiq Leafcutter Total 608 2850 131676 Significant 311 309 201 Table 5.1 : Number of SJ considered (Total) and called significant (Significant) for each method. However, when comparing the resulting gene and SJ sets, we observe a limited intersection among the results from the three methods ( Fig. 5.2 ) for genes and SJ. To further understand this issue, we reviewed the step-by-step process implemented by the methods. Overall, the three DJU methods share three steps, as mentioned before: Reads are extracted and filtered from the read alignments. Testable SJ or splicing events are identified, for example, by clustering. The SJ or splicing events counts are modelled. Fig. 5.2: Overlap between genes and SJ called significant by three DJU methods. JunctionSeq, Majiq and, Leafcutter deliver results that show a limited agreement among each other. We computed differential junction usage using the three methods on 15 RNA-Seq libraries with 3 groups, the three SIRV mixes. The resulting intersection shows that only small overlap genes ( A ) and SJ ( B ) called significant by the tools 9% (6 out of 66) and 16% (34 out of 212), respectively.","title":"DJU method produces results with little agreement"},{"location":"benchmark.html#benchmark","text":"We extracted all introns from the SIRV transcripts and classified between diff (changing between mixes) and no diff. Given the binary outcome from each tool, we analysed the following cases: True positive: diff intron called significant False-positive: no diff intron or intron in human contig called significant True negative: no diff not called significant False-negative: diff intron not called significant","title":"Benchmark"},{"location":"benchmark.html#results-from-the-methods-benchmark","text":"TN FP FN TP Majiq 2492 126 90 82 JunctionSeq 273 43 24 268 Leafcutter 131474 43 1 158 Table 5.2: Methods and number of SJ in each classification case Junctionseq achieves the highest number of TP calls and Junctionseq and Leafcutter the lowest number of FP calls. Based on that procedure, we proceeded with a two-class validation and computed the Receiver Operating Characteristic (ROC) curve and the precision-recall curve. Fig 5.3 ROC and Precision-recall curve : we observe the in this benchmark JunctionSeq outperforms Majiq and Leafcutter. The curves shows that Junctionseq outperforms the other two methods in the conditions we have analysed. Despite the punctual similarities, the implementation of these three state-of-art methods vary. Here we present a direct comparison on a set of artificial transcripts. The cumulative differences in who to define which SJ are extracted and tested; how much the method relies on the annotation; and the framework for statistical modelling explain the small intersections in Fig. 5.2 . In this case, Leafcutter suffers from a recall ceiling issue, because it ignores certain introns from the artificial transcripts. JunctionSeq has a clear advantage in this comparison because it relies heavily on the information of the annotation and the input annotation, that in this case, perfectly represents the structure of the transcripts. Majiq suffers from an excess of false-positive calls. Baltica aims to further study these implementations differences and potentially suggestion advice to minimize the effect of the limitations mentioned above. https://www.lexogen.com/sirvs/#sirvsdownload - Lexogen took no part in the experimental design neither we have any relationship with the company. \u21a9 Jennifer V Gerbracht, Volker Boehm, Thiago Britto-Borges, Sebastian Kallabis, Janica L Wiederstein, Simona Ciriello, Dominik U Aschemeier, Marcus Kr\u00fcger, Christian K Frese, Janine Altm\u00fcller, and et al. Casc3 promotes transcriptome-wide activation of nonsense-mediated decay by the exon junction complex. Nucleic Acids Research , 48(15):8626\u20138644, Jul 2020. URL: http://dx.doi.org/10.1093/nar/gkaa564 , doi:10.1093/nar/gkaa564 . \u21a9 \u21a9","title":"Results from the methods benchmark"},{"location":"bibliography.html","text":"1: Felix M\u00f6lder, Kim Philipp Jablonski, Brice Letcher, Michael B. Hall, Christopher H. Tomkins-Tinch, Vanessa Sochat, Jan Forster, Soohyun Lee, Sven O. Twardziok, Alexander Kanitz, and et al. Sustainable data analysis with snakemake. F1000Research , 10:33, Apr 2021. URL: http://dx.doi.org/10.12688/f1000research.29032.2 , doi:10.12688/f1000research.29032.2 . 2: R Core Team. R: A Language and Environment for Statistical Computing . R Foundation for Statistical Computing, Vienna, Austria, 2021. URL: https://www.R-project.org/ . 3: Michael Lawrence, Wolfgang Huber, Herv\u00e9 Pag\u00e8s, Patrick Aboyoun, Marc Carlson, Robert Gentleman, Martin T. Morgan, and Vincent J. Carey. Software for computing and annotating genomic ranges. PLoS Computational Biology , 9(8):e1003118, Aug 2013. URL: http://dx.doi.org/10.1371/journal.pcbi.1003118 , doi:10.1371/journal.pcbi.1003118 . 4: M. Lawrence, R. Gentleman, and V. Carey. Rtracklayer: an r package for interfacing with genome browsers. Bioinformatics , 25(14):1841\u20131842, May 2009. URL: http://dx.doi.org/10.1093/bioinformatics/btp328 , doi:10.1093/bioinformatics/btp328 . 5: Hadley Wickham, Mara Averick, Jennifer Bryan, Winston Chang, Lucy McGowan, Romain Fran\u00e7ois, Garrett Grolemund, Alex Hayes, Lionel Henry, Jim Hester, and et al. Welcome to the tidyverse. Journal of Open Source Software , 4(43):1686, Nov 2019. URL: http://dx.doi.org/10.21105/joss.01686 , doi:10.21105/joss.01686 . 6: Liguo Wang, Shengqin Wang, and Wei Li. RSeQC: quality control of RNA-seq experiments. Bioinformatics , 28(16):2184\u20132185, June 2012. URL: https://doi.org/10.1093/bioinformatics/bts356 , doi:10.1093/bioinformatics/bts356 . 7: Simon Andrews, Felix Krueger, Anne Segonds-Pichon, Laura Biggins, Christel Krueger, and Steven Wingett. FastQC. Babraham Institute, January 2012. URL: https://qubeshub.org/resources/fastqc . 8: Philip Ewels, M\u00e5ns Magnusson, Sverker Lundin, and Max K\u00e4ller. MultiQC: summarize analysis results for multiple tools and samples in a single report. Bioinformatics , 32(19):3047\u20133048, Jun 2016. URL: http://dx.doi.org/10.1093/bioinformatics/btw354 , doi:10.1093/bioinformatics/btw354 . 9: Shihao Shen, Juw Won Park, Zhi-xiang Lu, Lan Lin, Michael D. Henry, Ying Nian Wu, Qing Zhou, and Yi Xing. Rmats: robust and flexible detection of differential alternative splicing from replicate rna-seq data. Proceedings of the National Academy of Sciences , 111(51):E5593\u2013E5601, Dec 2014. URL: http://dx.doi.org/10.1073/pnas.1419161111 , doi:10.1073/pnas.1419161111 . 10: Stephen W. Hartley and James C. Mullikin. Detection and visualization of differential splicing in RNA-seq data with JunctionSeq. Nucleic Acids Research , pages gkw501, June 2016. URL: https://doi.org/10.1093/nar/gkw501 , doi:10.1093/nar/gkw501 . 11: Jorge Vaquero-Garcia, Alejandro Barrera, Matthew R Gazzara, Juan Gonzalez-Vallinas, Nicholas F Lahens, John B Hogenesch, Kristen W Lynch, and Yoseph Barash. A new view of transcriptome complexity and regulation through the lens of local splicing variations. eLife , February 2016. URL: https://doi.org/10.7554/elife.11752 , doi:10.7554/elife.11752 . 12: Yang I. Li, David A. Knowles, Jack Humphrey, Alvaro N. Barbeira, Scott P. Dickinson, Hae Kyung Im, and Jonathan K. Pritchard. Annotation-free quantification of RNA splicing using LeafCutter. Nature Genetics , 50(1):151\u2013158, December 2017. URL: https://doi.org/10.1038/s41588-017-0004-9 , doi:10.1038/s41588-017-0004-9 . 13: Sam Kovaka, Aleksey V. Zimin, Geo M. Pertea, Roham Razaghi, Steven L. Salzberg, and Mihaela Pertea. Transcriptome assembly from long-read rna-seq alignments with stringtie2. Genome Biology , Dec 2019. URL: http://dx.doi.org/10.1186/s13059-019-1910-1 , doi:10.1186/s13059-019-1910-1 . 14: Jennifer V Gerbracht, Volker Boehm, Thiago Britto-Borges, Sebastian Kallabis, Janica L Wiederstein, Simona Ciriello, Dominik U Aschemeier, Marcus Kr\u00fcger, Christian K Frese, Janine Altm\u00fcller, and et al. Casc3 promotes transcriptome-wide activation of nonsense-mediated decay by the exon junction complex. Nucleic Acids Research , 48(15):8626\u20138644, Jul 2020. URL: http://dx.doi.org/10.1093/nar/gkaa564 , doi:10.1093/nar/gkaa564 .","title":"References"},{"location":"dev_guide.html","text":"Development guidelines: \u00b6 Contributing to the documentation \u00b6 For the docs, we use MkDocs because of its flexibility: - mkdocs-material : look and feel - mkdocs-bibtex : literature reference - MkPDFs : PDF version Modify any of the doc files \u00b6 vi docs/setup.md Test the changes locally \u00b6 mkdocs serve If everything looks fine you can submit a patch or pull-request. Deploy changes \u00b6 This requires permissions from the GitHub organization. mkdocs gh-deploy Setting up mkdocs \u00b6 # osx specific settings conda install pango cairo pip install mkdocs pip install mkdocs-material pip install mkdocs-bibtex pip install -e git+https://github.com/jwaschkau/mkpdfs-mkdocs-plugin.git#egg = mkpdfs-mkdocs-plugin # osx specific settings export LC_ALL = en_US.UTF-8 export LANG = en_US.UTF-8 Updating docker containers \u00b6 The dockerfiles for containers reside at the docker/ directory. Some of the environments use conda recipes, which reside in the envs/ directory. After updating a recipe, to build and upload its container, one should use: cd Baltica/ docker build -f <dockerfile> --tag <name>:<tag> . docker push <tag> For example, - dockerfile: docker/baltica/1.0/Dockerfile - name: tbrittoborges/baltica - tag: 1.0 Once the container is updated, its tag version (tag) should be updated as well as it the container directive in the snakemake workflows. docker hub hosts the container and can change this location at the container directive at the snakefiles. Testing Baltica \u00b6 Baltica's continuous integration testing suite is under development.","title":"Development guidelines"},{"location":"dev_guide.html#development-guidelines","text":"","title":"Development guidelines:"},{"location":"dev_guide.html#contributing-to-the-documentation","text":"For the docs, we use MkDocs because of its flexibility: - mkdocs-material : look and feel - mkdocs-bibtex : literature reference - MkPDFs : PDF version","title":"Contributing to the documentation"},{"location":"dev_guide.html#modify-any-of-the-doc-files","text":"vi docs/setup.md","title":"Modify any of the doc files"},{"location":"dev_guide.html#test-the-changes-locally","text":"mkdocs serve If everything looks fine you can submit a patch or pull-request.","title":"Test the changes locally"},{"location":"dev_guide.html#deploy-changes","text":"This requires permissions from the GitHub organization. mkdocs gh-deploy","title":"Deploy changes"},{"location":"dev_guide.html#setting-up-mkdocs","text":"# osx specific settings conda install pango cairo pip install mkdocs pip install mkdocs-material pip install mkdocs-bibtex pip install -e git+https://github.com/jwaschkau/mkpdfs-mkdocs-plugin.git#egg = mkpdfs-mkdocs-plugin # osx specific settings export LC_ALL = en_US.UTF-8 export LANG = en_US.UTF-8","title":"Setting up mkdocs"},{"location":"dev_guide.html#updating-docker-containers","text":"The dockerfiles for containers reside at the docker/ directory. Some of the environments use conda recipes, which reside in the envs/ directory. After updating a recipe, to build and upload its container, one should use: cd Baltica/ docker build -f <dockerfile> --tag <name>:<tag> . docker push <tag> For example, - dockerfile: docker/baltica/1.0/Dockerfile - name: tbrittoborges/baltica - tag: 1.0 Once the container is updated, its tag version (tag) should be updated as well as it the container directive in the snakemake workflows. docker hub hosts the container and can change this location at the container directive at the snakefiles.","title":"Updating docker containers"},{"location":"dev_guide.html#testing-baltica","text":"Baltica's continuous integration testing suite is under development.","title":"Testing Baltica"},{"location":"faq.html","text":"What you mean with baltica provides a interface between users and DJU methods : \u00b6 There are many specificities to the DJU methods, and while running one method is not too complicated, figuring out how to run multiple methods is time-demanding. Baltica aims to facilitate this task so that methods results can be produced and compared. Snakemake Error: Directory cannot be locked. : \u00b6 This error happens when there is an error or failure during the workflow execution, and Snakemake's process does not have the opportunity to unlock the directory. Use baltica <workflow> <config> --unlock to resolve it. See more here ERROR lines in majiq_gtf_to_gff: \u00b6 Most of the errors in this rules are not fatal. See here for the diagnostics. rmats empty or mostly empty outputs \u00b6 This error can be either issue with: - The read length parameter . To resolve it, increase the read length parameter or use --variable-read-length in Baltica configuration. - Or an error with the stack size limit . To resolve it increase the stack size in bash with ulimit -c unlimited . Junctionseq bpapply error: \u00b6 This error occurs in the junctionseq_analysis rule, which uses multiple threads with BiocParallel. One can overcome this issue by setting threads to 1 on the said rule. Junctionseq analysis thread error \u00b6 Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index xxx out of bounds for length xxx It is complaining the maximum read length is longer than the read length input. First, check the maximum read length in the quality control report and then increase the read_len parameter on Baltica config. How does Baltica compute the score for each DJU method? \u00b6 The different DJU methods are pretty different in many aspects, including how they compute the final test statistic, and we use the following rule to compute the score for the Baltica table (higher is better): - majiq score = 1 - non-changing-threshold (probability of |\u0394\u03a8| > 0.2, by default) - leafcutter = 1 - p.adjust - junctionseq = 1 - padjust - rmats = 1 - FDR I see a message: /bin/bash: /root/.bashrc: Permission denied . What is wrong? \u00b6 This error message is benign and, in our experience, does not affect workflow execution.","title":"Frequently asked questions"},{"location":"faq.html#what-you-mean-with-baltica-provides-a-interface-between-users-and-dju-methods","text":"There are many specificities to the DJU methods, and while running one method is not too complicated, figuring out how to run multiple methods is time-demanding. Baltica aims to facilitate this task so that methods results can be produced and compared.","title":"What you mean with baltica provides a interface between users and DJU methods:"},{"location":"faq.html#snakemake-error-directory-cannot-be-locked","text":"This error happens when there is an error or failure during the workflow execution, and Snakemake's process does not have the opportunity to unlock the directory. Use baltica <workflow> <config> --unlock to resolve it. See more here","title":"Snakemake Error: Directory cannot be locked.:"},{"location":"faq.html#error-lines-in-majiq_gtf_to_gff","text":"Most of the errors in this rules are not fatal. See here for the diagnostics.","title":"ERROR lines in majiq_gtf_to_gff:"},{"location":"faq.html#rmats-empty-or-mostly-empty-outputs","text":"This error can be either issue with: - The read length parameter . To resolve it, increase the read length parameter or use --variable-read-length in Baltica configuration. - Or an error with the stack size limit . To resolve it increase the stack size in bash with ulimit -c unlimited .","title":"rmats empty or mostly empty outputs"},{"location":"faq.html#junctionseq-bpapply-error","text":"This error occurs in the junctionseq_analysis rule, which uses multiple threads with BiocParallel. One can overcome this issue by setting threads to 1 on the said rule.","title":"Junctionseq bpapply error:"},{"location":"faq.html#junctionseq-analysis-thread-error","text":"Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index xxx out of bounds for length xxx It is complaining the maximum read length is longer than the read length input. First, check the maximum read length in the quality control report and then increase the read_len parameter on Baltica config.","title":"Junctionseq analysis thread error"},{"location":"faq.html#how-does-baltica-compute-the-score-for-each-dju-method","text":"The different DJU methods are pretty different in many aspects, including how they compute the final test statistic, and we use the following rule to compute the score for the Baltica table (higher is better): - majiq score = 1 - non-changing-threshold (probability of |\u0394\u03a8| > 0.2, by default) - leafcutter = 1 - p.adjust - junctionseq = 1 - padjust - rmats = 1 - FDR","title":"How does Baltica compute the score for each DJU method?"},{"location":"faq.html#i-see-a-message-binbash-rootbashrc-permission-denied-what-is-wrong","text":"This error message is benign and, in our experience, does not affect workflow execution.","title":"I see a message: /bin/bash: /root/.bashrc: Permission denied. What is wrong?"},{"location":"integration.html","text":"Integration \u00b6 Parsing the results of the method \u00b6 The first step in the analysis workflow is parsing and processing the DJU methods' output with scripts/parse_{method}_output.R scripts as follows: The resulting text output from the DJU methods is parsed and loaded as R data frames The data frames are pivoted in a longer format to have one junction and one comparison per row Warning RMATs, Majiq, and Leafcutter use AS events to test for DJU, so metrics are associated with a group and not the SJ. In Baltica, we split these groups in SJ, and multiple SJ may have the same metric, for example, test statistics. Note For unstranded RNA-seq libraries, JunctionSeq output genomic coordinates without the strand information. Therefore, we support the integration by eliminating the strand from the analysis. However, we recommend against generating unstranded RNA-seq libraries in 2021. Result integration \u00b6 One challenge for the integration of DJU results is that the methods use different genomic coordinate systems. The coordinates system's differences are due to the method implementation: methods can be 0-indexed (BED format) versus 1-indexed (GTF format) or use the exonic versus intronic coordinates to represent the SJ genomic position. To harmonize the different coordiantes systems, we first: Compute the genomic overlap between introns in the reference annotation (subject) and a set of SJ output from a method (query) Next, we compute the coordinate offset between subject and query, determine the most frequent difference in start and end coordinates Finally, apply corrections to the coordinates in the query, and repeat it for each method Annotating the results \u00b6 We annotate the results with information from genes and transcripts hosting the SJ. For this, we use the de novo transcript annotation at stringtie/merged/merged.combined.gtf . Commonly, multiple transcripts share an intron so that a single intron may be annotated with multiple transcripts. These are the columns assigned after the annotation: Table 1: Annotation description \u00b6 Column name Description comparison pairwise comparison as {case}_vs_{control} chr seqname or genomic contig start intron start position for the SJ end intron end position strand RNA strand that encodes that gene gene the gene symbol e2 - e1 acceptor and donor exons number, if in + strand else the inverse tx_id transcript identifier from the combined annotation transcript_name transcript name class_code association between reference transcript and novel transcript ( seq fig1 for details ) Selecting optimal parameters for de novo transcriptome assembly \u00b6 Warning The section below was obtained in a previous Baltica release, using stringtie v1.2.X, but we don't expect major changes in current version. We found that the parameters used to obtain the de novo transcriptome are critical for maximum integration between the GTF and the SJ from DJU methods. Fig 1 shows a parameter scan where we vary the group, -j (minimum junction coverage), -c (minimum coverage), and -f (minimum isoform proportion) and compute the number of transcripts that match with SJ called significantly. As expected, the merged annotation and not the group-specific annotation have the highest rate of annotated introns. The crucial result here is the dependency of the -f parameter, which is also associated with an increased number of annotated introns. As we confirmed this behavior in other datasets, we decided to use -c 3 -j 3 -f 0.01 as default values in Baltica. The higher coverage ( -c and -j ) values counter the potential noise of transcripts with low abundance. Fig 1 :Parameter scan to maximize the number of introns annotated. We have run Stringtie with multipleparameters of merged annotation or group annotation; junction coverage of 1, 2, or 3; coverage of 1, 2, 3, and minimum isoform fraction of 0.1, 0.01, or 0.001. The result shows a dependency of the minimum isoform fraction parameter, which needs to be minimized to increase the proportion of annotated SJ, as expected. Assigning AS type \u00b6 Biological motivation \u00b6 Identifying the type of AS is critical to understand a potential molecular mechanism for AS events. SRSF2 is a relevant example in this context. SRSF2 is splicing factors from the SR family that are known for auto-regulation. In certain conditions, the SRSF2 transcript can activate the nonsense-mediated decay by either including a new exon containing a premature stop codon or an intron in 3' UTR. These changes lead to transcript degradation and overall reduction of gene expression. Thus, the reduction of SRSF2 protein level leads to widespread exon skipping. Identifying such patterns is critical to understanding which splicing regulators are driving the observed splicing changes, and it enables further analysis of AS events of a specific type. Implementation \u00b6 In Baltica, we use a geometric approach to define AS in three classes: ES, for exon skipping A3SS, for alternative 3' splice-site A5SS, for alternative 5' splice-site Figure 2 details how we use the distance between features start and end to determine the AS type. Fig 2 : AS type assignment in Baltica. Baltica uses the genomic coordinates from the SJ and its overlapping exons to assigning AS type to SJ and its overlapping exons. Because many exons may be affected, multiple assignments are output. For example, donor and acceptor exons are assigned as JS and JE, respectively. Simplify the AS event \u00b6 Because most of the final users are only interested in the list of genomic ranges, gene names, or event types, we offer a simplified output that removes redundant information. This step helps generate a final report. References \u00b6","title":"DJU methods result integration"},{"location":"integration.html#integration","text":"","title":"Integration"},{"location":"integration.html#parsing-the-results-of-the-method","text":"The first step in the analysis workflow is parsing and processing the DJU methods' output with scripts/parse_{method}_output.R scripts as follows: The resulting text output from the DJU methods is parsed and loaded as R data frames The data frames are pivoted in a longer format to have one junction and one comparison per row Warning RMATs, Majiq, and Leafcutter use AS events to test for DJU, so metrics are associated with a group and not the SJ. In Baltica, we split these groups in SJ, and multiple SJ may have the same metric, for example, test statistics. Note For unstranded RNA-seq libraries, JunctionSeq output genomic coordinates without the strand information. Therefore, we support the integration by eliminating the strand from the analysis. However, we recommend against generating unstranded RNA-seq libraries in 2021.","title":"Parsing the results of the method"},{"location":"integration.html#result-integration","text":"One challenge for the integration of DJU results is that the methods use different genomic coordinate systems. The coordinates system's differences are due to the method implementation: methods can be 0-indexed (BED format) versus 1-indexed (GTF format) or use the exonic versus intronic coordinates to represent the SJ genomic position. To harmonize the different coordiantes systems, we first: Compute the genomic overlap between introns in the reference annotation (subject) and a set of SJ output from a method (query) Next, we compute the coordinate offset between subject and query, determine the most frequent difference in start and end coordinates Finally, apply corrections to the coordinates in the query, and repeat it for each method","title":"Result integration"},{"location":"integration.html#annotating-the-results","text":"We annotate the results with information from genes and transcripts hosting the SJ. For this, we use the de novo transcript annotation at stringtie/merged/merged.combined.gtf . Commonly, multiple transcripts share an intron so that a single intron may be annotated with multiple transcripts. These are the columns assigned after the annotation:","title":"Annotating the results"},{"location":"integration.html#table-1-annotation-description","text":"Column name Description comparison pairwise comparison as {case}_vs_{control} chr seqname or genomic contig start intron start position for the SJ end intron end position strand RNA strand that encodes that gene gene the gene symbol e2 - e1 acceptor and donor exons number, if in + strand else the inverse tx_id transcript identifier from the combined annotation transcript_name transcript name class_code association between reference transcript and novel transcript ( seq fig1 for details )","title":"Table 1: Annotation description"},{"location":"integration.html#selecting-optimal-parameters-for-de-novo-transcriptome-assembly","text":"Warning The section below was obtained in a previous Baltica release, using stringtie v1.2.X, but we don't expect major changes in current version. We found that the parameters used to obtain the de novo transcriptome are critical for maximum integration between the GTF and the SJ from DJU methods. Fig 1 shows a parameter scan where we vary the group, -j (minimum junction coverage), -c (minimum coverage), and -f (minimum isoform proportion) and compute the number of transcripts that match with SJ called significantly. As expected, the merged annotation and not the group-specific annotation have the highest rate of annotated introns. The crucial result here is the dependency of the -f parameter, which is also associated with an increased number of annotated introns. As we confirmed this behavior in other datasets, we decided to use -c 3 -j 3 -f 0.01 as default values in Baltica. The higher coverage ( -c and -j ) values counter the potential noise of transcripts with low abundance. Fig 1 :Parameter scan to maximize the number of introns annotated. We have run Stringtie with multipleparameters of merged annotation or group annotation; junction coverage of 1, 2, or 3; coverage of 1, 2, 3, and minimum isoform fraction of 0.1, 0.01, or 0.001. The result shows a dependency of the minimum isoform fraction parameter, which needs to be minimized to increase the proportion of annotated SJ, as expected.","title":"Selecting optimal parameters for de novo transcriptome assembly"},{"location":"integration.html#assigning-as-type","text":"","title":"Assigning AS type"},{"location":"integration.html#biological-motivation","text":"Identifying the type of AS is critical to understand a potential molecular mechanism for AS events. SRSF2 is a relevant example in this context. SRSF2 is splicing factors from the SR family that are known for auto-regulation. In certain conditions, the SRSF2 transcript can activate the nonsense-mediated decay by either including a new exon containing a premature stop codon or an intron in 3' UTR. These changes lead to transcript degradation and overall reduction of gene expression. Thus, the reduction of SRSF2 protein level leads to widespread exon skipping. Identifying such patterns is critical to understanding which splicing regulators are driving the observed splicing changes, and it enables further analysis of AS events of a specific type.","title":"Biological motivation"},{"location":"integration.html#implementation","text":"In Baltica, we use a geometric approach to define AS in three classes: ES, for exon skipping A3SS, for alternative 3' splice-site A5SS, for alternative 5' splice-site Figure 2 details how we use the distance between features start and end to determine the AS type. Fig 2 : AS type assignment in Baltica. Baltica uses the genomic coordinates from the SJ and its overlapping exons to assigning AS type to SJ and its overlapping exons. Because many exons may be affected, multiple assignments are output. For example, donor and acceptor exons are assigned as JS and JE, respectively.","title":"Implementation"},{"location":"integration.html#simplify-the-as-event","text":"Because most of the final users are only interested in the list of genomic ranges, gene names, or event types, we offer a simplified output that removes redundant information. This step helps generate a final report.","title":"Simplify the AS event"},{"location":"integration.html#references","text":"","title":"References"},{"location":"intro.html","text":"Introduction \u00b6 For motivation and review of state of the art, please check: Thiago Britto-Borges, Volker Boehm, Niels H. Gehring and Christoph Dieterich (2020) Baltica: integrated splice junction usage analysis. Manuscript in preparation. Tips on RNA-Seq aiming differential splicing detection \u00b6 If you aim to resolve mRNA isoforms with relatively low abundance, you should design the RNA-seq experiment accordingly. The expert suggestion is to sequence around 40 to 60 million reads pairs. This parameter is particularly relevant for complex RNA libraries, but it can be insufficient to saturate novel SJ, in our experience. Read length and paired-end reads are also critical for SJ identification, and longer reads offer more coverage of the exons boundaries. Thus, the target read length should be around 100 nucleotides for Illumina RNA-seq to maximize the read overhang length and, consequently, maximize the quality of the alignments. In the Baltica manuscript, we propose an approach to integrate DJU results from Illumina to DJU results from third-generation sequencing. Also, databases such as the CHESS can provide additional evidence for splice sites absent in the annotation.","title":"Introduction"},{"location":"intro.html#introduction","text":"For motivation and review of state of the art, please check: Thiago Britto-Borges, Volker Boehm, Niels H. Gehring and Christoph Dieterich (2020) Baltica: integrated splice junction usage analysis. Manuscript in preparation.","title":"Introduction"},{"location":"intro.html#tips-on-rna-seq-aiming-differential-splicing-detection","text":"If you aim to resolve mRNA isoforms with relatively low abundance, you should design the RNA-seq experiment accordingly. The expert suggestion is to sequence around 40 to 60 million reads pairs. This parameter is particularly relevant for complex RNA libraries, but it can be insufficient to saturate novel SJ, in our experience. Read length and paired-end reads are also critical for SJ identification, and longer reads offer more coverage of the exons boundaries. Thus, the target read length should be around 100 nucleotides for Illumina RNA-seq to maximize the read overhang length and, consequently, maximize the quality of the alignments. In the Baltica manuscript, we propose an approach to integrate DJU results from Illumina to DJU results from third-generation sequencing. Also, databases such as the CHESS can provide additional evidence for splice sites absent in the annotation.","title":"Tips on RNA-Seq aiming differential splicing detection"},{"location":"proj-config.html","text":"Baltica project configuration \u00b6 Baltica requires a project configuration file as input. For a template see here . For a programmatic solution to generate the configuration, use the script baltica/write_new_config.R . Method specific parameters are detailed in the Workflow implementation page. Warning Baltica project requires that configuration been update. Users should use the full path to files. The sample names for the samples parameters uses a underscore (_) to separate the sample name and replicate number, like in mix_1, so the sample should not contain spaces or underscores. Note The Required column flags parameters without a default value. General parameters description \u00b6 Parameter Description Required path project path \u2713 sample_path path to the parent directory for aligment files \u2713 samples sample name and directory formated as \"{sample_name}: {path_to_sample) \u2713 contrasts list of contrasts names ( format ) \u2713 assembly assembly name on UCSC Browser strandness one of fr-firststrand, fr-secondstrand or none (unstranded) \u2713 read_len maximun read length \u2713 ref path to reference annotation in the GTF format \u2713 ref_fa path to reference annotation in the FASTA format \u2713 project_authors project author name, used in the report project_title project title name, used in file names and report orthogonal_result path to results from orthonal experiment, such as ONT RNA-seq ( see ) baltica_max_table maximum number of rows for the Baltica table in the HTML report Pairwise comparisons \u00b6 contrasts : { case1 } -vs-{control} : - { case1 } - { control } { cas2 } -vs-{control} : - { case2 } - { control } Note junctionseq and leafcutter support more complex experimental designs, which were not implemented in Baltica. Orthogonal result \u00b6 Full path to GFF or BED with a valid score column. Optionally a comparison or name column containing the experimental comparisons. Otherwise, only the first contrast of the project is used. This parameter allows Baltica to integrate a validation dataset obtained with third-generation sequencing. majiq specific paramers \u00b6 majiq manual Parameter Original parameter Description rule majiq_build: ( majiq deltapsi ) majiq_min_experiments --min-experiments minimum number of experiments to filter with --minreads (default 1.0 - all experiments) majiq_minreads --minreads Discard SJ with less than --minreads reads majiq_min_denovo --min-denovo Discard novel SJ with less than --min-denovo reads rule majiq_deltapsi ( majiq deltapsi ) majiq_minreads --minreads same as above rule majiq_voila ( voila tsv ) majiq_non_changing_threshold --non-changing-threshold majiq_threshold --threshold junctionseq specific paramers \u00b6 qorts manual junctionseq manual Parameter Original parameter Description rule junctionseq_qc ( qorts QC ) is_single_end --singleEnded Flag single end libraries rule junctionseq_merge ( qorts mergeNovelSplices ) junctionseq_mincount --minCount Discard SJ with less than --minCount reads leafcutter specific paramers \u00b6 regtools manual leafcutter manual Parameter Original parameter Description rule leafcutter_bam2junc ( regtools junctions extract ) leafcutter_minimum_anchor_length -a Discard reads with overanging length lower than -a leafcutter_minimum_intron_size -i Minimum intron size leafcutter_maximum_intron_size -I Maximum intron size rule leafcutter_differential_splicing leafcutter_min_coverage --min_coverage desc leafcutter_min_samples_per_group -g Discard SJ used in less than -g samples leafcutter_min_samples_per_intron -i Discard SJ with less than --min_coverage in -i samples in each group rmats specific paramers \u00b6 rmats manual Parameter original parameter Description rule rmats_run ( rmats.py ) rmats_allow_clipping --allow-clipping Allow clipped reads rmats_variable_read_length --variable-read-length Allow reads with variable-length rmats_novel_ss --novelSS Allow the detecting unannotated SJ rmats_extra none Pass extra arguments to rmats.py","title":"Project configuration"},{"location":"proj-config.html#baltica-project-configuration","text":"Baltica requires a project configuration file as input. For a template see here . For a programmatic solution to generate the configuration, use the script baltica/write_new_config.R . Method specific parameters are detailed in the Workflow implementation page. Warning Baltica project requires that configuration been update. Users should use the full path to files. The sample names for the samples parameters uses a underscore (_) to separate the sample name and replicate number, like in mix_1, so the sample should not contain spaces or underscores. Note The Required column flags parameters without a default value.","title":"Baltica project configuration"},{"location":"proj-config.html#general-parameters-description","text":"Parameter Description Required path project path \u2713 sample_path path to the parent directory for aligment files \u2713 samples sample name and directory formated as \"{sample_name}: {path_to_sample) \u2713 contrasts list of contrasts names ( format ) \u2713 assembly assembly name on UCSC Browser strandness one of fr-firststrand, fr-secondstrand or none (unstranded) \u2713 read_len maximun read length \u2713 ref path to reference annotation in the GTF format \u2713 ref_fa path to reference annotation in the FASTA format \u2713 project_authors project author name, used in the report project_title project title name, used in file names and report orthogonal_result path to results from orthonal experiment, such as ONT RNA-seq ( see ) baltica_max_table maximum number of rows for the Baltica table in the HTML report","title":"General parameters description"},{"location":"proj-config.html#pairwise-comparisons","text":"contrasts : { case1 } -vs-{control} : - { case1 } - { control } { cas2 } -vs-{control} : - { case2 } - { control } Note junctionseq and leafcutter support more complex experimental designs, which were not implemented in Baltica.","title":"Pairwise comparisons"},{"location":"proj-config.html#orthogonal-result","text":"Full path to GFF or BED with a valid score column. Optionally a comparison or name column containing the experimental comparisons. Otherwise, only the first contrast of the project is used. This parameter allows Baltica to integrate a validation dataset obtained with third-generation sequencing.","title":"Orthogonal result"},{"location":"proj-config.html#majiq-specific-paramers","text":"majiq manual Parameter Original parameter Description rule majiq_build: ( majiq deltapsi ) majiq_min_experiments --min-experiments minimum number of experiments to filter with --minreads (default 1.0 - all experiments) majiq_minreads --minreads Discard SJ with less than --minreads reads majiq_min_denovo --min-denovo Discard novel SJ with less than --min-denovo reads rule majiq_deltapsi ( majiq deltapsi ) majiq_minreads --minreads same as above rule majiq_voila ( voila tsv ) majiq_non_changing_threshold --non-changing-threshold majiq_threshold --threshold","title":"majiq specific paramers"},{"location":"proj-config.html#junctionseq-specific-paramers","text":"qorts manual junctionseq manual Parameter Original parameter Description rule junctionseq_qc ( qorts QC ) is_single_end --singleEnded Flag single end libraries rule junctionseq_merge ( qorts mergeNovelSplices ) junctionseq_mincount --minCount Discard SJ with less than --minCount reads","title":"junctionseq specific paramers"},{"location":"proj-config.html#leafcutter-specific-paramers","text":"regtools manual leafcutter manual Parameter Original parameter Description rule leafcutter_bam2junc ( regtools junctions extract ) leafcutter_minimum_anchor_length -a Discard reads with overanging length lower than -a leafcutter_minimum_intron_size -i Minimum intron size leafcutter_maximum_intron_size -I Maximum intron size rule leafcutter_differential_splicing leafcutter_min_coverage --min_coverage desc leafcutter_min_samples_per_group -g Discard SJ used in less than -g samples leafcutter_min_samples_per_intron -i Discard SJ with less than --min_coverage in -i samples in each group","title":"leafcutter specific paramers"},{"location":"proj-config.html#rmats-specific-paramers","text":"rmats manual Parameter original parameter Description rule rmats_run ( rmats.py ) rmats_allow_clipping --allow-clipping Allow clipped reads rmats_variable_read_length --variable-read-length Allow reads with variable-length rmats_novel_ss --novelSS Allow the detecting unannotated SJ rmats_extra none Pass extra arguments to rmats.py","title":"rmats specific paramers"},{"location":"release-notes.html","text":"Change log \u00b6 v1.1.2 Unreleased \u00b6 Add support to unstranded RNA-seq data Add scripts for benchmark Add a new configuration bind_paths that allow integrating bam files from different projects v1.1.1 July 23, 2021 (released in September 7 2021) \u00b6 Add rmats workflow Add scrips for parsing for rmats and updated analysis to support the method Create the benchmark with the ONT Nanopore-seq Update benchmaks, included difference comparison for SIRV benchmark Split annotation and AS type assigment functions Update baltica table algorithm Add support for singularity container via snakemake, with container recipes baltica qc config.yaml --use-singularity Add parsing method for gffcompare tracking output Update configuration file to expose important parameters from the DJU methods Add end-to-end analysis with baltica all config Experiment with meta-score (gradient boosted trees) Add baltica report and improved on report summaries Add orthogonal dataset use-case, to integrate third generation sequencing to the baltica table Change strand parameter to \"fr-firststrand\": \"reverse\", \"fr-secondstrand\": \"forward\" or unstranded, fix error in rmats strand v1.0 September 17, 2020 \u00b6 Add is_novel column, indication introns not into the reference annotation Remove unitended columns (X1, ...) from the report v1.0 - July 23, 2020 \u00b6 First public release comprises of DJU methods Leafcutter, Junctionseq and Majiq. Stringtie for de novo transcriptomics assembly. FastQC and MultiQC (#1).","title":"Release notes"},{"location":"release-notes.html#change-log","text":"","title":"Change log"},{"location":"release-notes.html#v112-unreleased","text":"Add support to unstranded RNA-seq data Add scripts for benchmark Add a new configuration bind_paths that allow integrating bam files from different projects","title":"v1.1.2  Unreleased "},{"location":"release-notes.html#v111-july-23-2021-released-in-september-7-2021","text":"Add rmats workflow Add scrips for parsing for rmats and updated analysis to support the method Create the benchmark with the ONT Nanopore-seq Update benchmaks, included difference comparison for SIRV benchmark Split annotation and AS type assigment functions Update baltica table algorithm Add support for singularity container via snakemake, with container recipes baltica qc config.yaml --use-singularity Add parsing method for gffcompare tracking output Update configuration file to expose important parameters from the DJU methods Add end-to-end analysis with baltica all config Experiment with meta-score (gradient boosted trees) Add baltica report and improved on report summaries Add orthogonal dataset use-case, to integrate third generation sequencing to the baltica table Change strand parameter to \"fr-firststrand\": \"reverse\", \"fr-secondstrand\": \"forward\" or unstranded, fix error in rmats strand","title":"v1.1.1  July 23, 2021 (released in September 7 2021) "},{"location":"release-notes.html#v10-september-17-2020","text":"Add is_novel column, indication introns not into the reference annotation Remove unitended columns (X1, ...) from the report","title":"v1.0  September 17, 2020"},{"location":"release-notes.html#v10-july-23-2020","text":"First public release comprises of DJU methods Leafcutter, Junctionseq and Majiq. Stringtie for de novo transcriptomics assembly. FastQC and MultiQC (#1).","title":"v1.0 - July 23, 2020"},{"location":"report.html","text":"Baltica output \u00b6 Baltica framework produces two files as output: - an R markdown report - an excel spreadsheet Note If available, the orthogonal dataset is treated as a new method named orthogonal. Baltica table spreadsheet \u00b6 results/baltica_table_{proj_name}.xlsx The spreadsheet contains the complete set of coordinate output by methods and comparisons. In addition, there are a column for the combination of methods and comparisons plus the columns for the annotation: coordinates: junction genomic coordinate in the format: {chr}:{start}-{end}:{strand} (strand omitted if none) score columns: in the format: {method}_{comparisons} is_novel: whether the splicing junction is or not annotated gene_name: the gene name obtained from the de novo annotation workflow transcript_name: transcript name from the de novo annotation class_code: transcript class association to the reference annotation transcript, please see Fig 1 in the GFF Utilities paper for details exon_number: pairs of exon numbers from the de novo annotation. First of the pair is the donor exon if the feature is the positive strand; otherwise acceptor as_type: type of AS for each junction exon skipping (ES), alternative 3' splice site (A3SS), alternative 5' splice site (A5SS) Currently, the HTML report comprises two sections: Common splice junctions \u00b6 The upset plot shows the combination of distinct sets of calls (score > 0.95) from each method and contrast. The plot helps to compare the common calls among sets. The complement sets are ignored, as these sets usually have a high number. Baltica table \u00b6 This interactive HTML table provides the top 1,000 (or baltica_max_table in the configuration file) sorted by the sum of the scores. Extra annotation is available upon clicking on \u25b6. In addition, the coordinates columns link to the UCSC genome browser. Regional URL for UCSC GB can be selected with ucsc_url , and assembly should be selected with the assembly configuration Baltica report configuration \u00b6 Change the following options on your project configuration to change the report: project_authors: name of the persons running the project project_title: name of the files and report title baltica_max_table: maximum number of rows on the HTML table assembly: assembly used for linking with the genome browser ucsc_url: URL for the genome browser, like http://genome-euro.ucsc.edu for the European mirror Reproducibility \u00b6 This section provides the information necessary to reproduce the report, including project configuration and R package version.","title":"Baltica output"},{"location":"report.html#baltica-output","text":"Baltica framework produces two files as output: - an R markdown report - an excel spreadsheet Note If available, the orthogonal dataset is treated as a new method named orthogonal.","title":"Baltica output"},{"location":"report.html#baltica-table-spreadsheet","text":"results/baltica_table_{proj_name}.xlsx The spreadsheet contains the complete set of coordinate output by methods and comparisons. In addition, there are a column for the combination of methods and comparisons plus the columns for the annotation: coordinates: junction genomic coordinate in the format: {chr}:{start}-{end}:{strand} (strand omitted if none) score columns: in the format: {method}_{comparisons} is_novel: whether the splicing junction is or not annotated gene_name: the gene name obtained from the de novo annotation workflow transcript_name: transcript name from the de novo annotation class_code: transcript class association to the reference annotation transcript, please see Fig 1 in the GFF Utilities paper for details exon_number: pairs of exon numbers from the de novo annotation. First of the pair is the donor exon if the feature is the positive strand; otherwise acceptor as_type: type of AS for each junction exon skipping (ES), alternative 3' splice site (A3SS), alternative 5' splice site (A5SS) Currently, the HTML report comprises two sections:","title":"Baltica table spreadsheet"},{"location":"report.html#common-splice-junctions","text":"The upset plot shows the combination of distinct sets of calls (score > 0.95) from each method and contrast. The plot helps to compare the common calls among sets. The complement sets are ignored, as these sets usually have a high number.","title":"Common splice junctions"},{"location":"report.html#baltica-table","text":"This interactive HTML table provides the top 1,000 (or baltica_max_table in the configuration file) sorted by the sum of the scores. Extra annotation is available upon clicking on \u25b6. In addition, the coordinates columns link to the UCSC genome browser. Regional URL for UCSC GB can be selected with ucsc_url , and assembly should be selected with the assembly configuration","title":"Baltica table"},{"location":"report.html#baltica-report-configuration","text":"Change the following options on your project configuration to change the report: project_authors: name of the persons running the project project_title: name of the files and report title baltica_max_table: maximum number of rows on the HTML table assembly: assembly used for linking with the genome browser ucsc_url: URL for the genome browser, like http://genome-euro.ucsc.edu for the European mirror","title":"Baltica report configuration"},{"location":"report.html#reproducibility","text":"This section provides the information necessary to reproduce the report, including project configuration and R package version.","title":"Reproducibility"},{"location":"rmats_notes.html","text":"Installation \u00b6 module load samtools conda create -n rmats \"python==3.6\" cython numpy conda activate rmats git clone https://github.com/Xinglab/rmats-turbo.git cd rmats-turbo # change lines 11, 12 from rMATS_pipeline/setup.py # os.environ['CC'] = '/usr/bin/cc' # os.environ['CXX'] = '/usr/bin/c++' ./build_rmats --no-paired-model > build.log # comment lines, 39, 40 and 52 from test_rmats ./test_rmats # three test will fail # test (tests.paired_stats.test.FilteredEventTest) ... FAIL # test (tests.paired_stats.test.OneEventTest) ... FAIL # test (tests.paired_stats.test.TwoEventTest) ... FAIL Notes on the method \u00b6 For multi gene locus, rMATS may mismatch the origin of the gene with novel AS event https://github.com/Xinglab/rmats-turbo/issues/79#issuecomment-763148314 rMATS only check annotated introns for IR https://github.com/Xinglab/rmats-turbo/issues/65#issuecomment-740722530","title":"Rmats notes"},{"location":"rmats_notes.html#installation","text":"module load samtools conda create -n rmats \"python==3.6\" cython numpy conda activate rmats git clone https://github.com/Xinglab/rmats-turbo.git cd rmats-turbo # change lines 11, 12 from rMATS_pipeline/setup.py # os.environ['CC'] = '/usr/bin/cc' # os.environ['CXX'] = '/usr/bin/c++' ./build_rmats --no-paired-model > build.log # comment lines, 39, 40 and 52 from test_rmats ./test_rmats # three test will fail # test (tests.paired_stats.test.FilteredEventTest) ... FAIL # test (tests.paired_stats.test.OneEventTest) ... FAIL # test (tests.paired_stats.test.TwoEventTest) ... FAIL","title":"Installation"},{"location":"rmats_notes.html#notes-on-the-method","text":"For multi gene locus, rMATS may mismatch the origin of the gene with novel AS event https://github.com/Xinglab/rmats-turbo/issues/79#issuecomment-763148314 rMATS only check annotated introns for IR https://github.com/Xinglab/rmats-turbo/issues/65#issuecomment-740722530","title":"Notes on the method"},{"location":"setup.html","text":"Getting started \u00b6 Quick example: \u00b6 If Baltica dependencies, baltica configuration and cluster configuration are available, use: baltica <workflow> <config> --use-singularity Note Singularity requires a mountable temp directory, we recommend setting /tmp with export TMPDIR=/tmp/ workflow : all: run end-to-end wokflows qc: run quality control stringtie: run de novo and guided transcriptome assembly rmats junctionseq majiq leafcutter analysis: run scripts for integration, annotation and reporting config : project configuration file Use --profile <cluster> with a Snakemake cluster profile or set the number of avaiable cores with --cores . For more Snakemake parameters, check their documentation . Warning Baltica is under active development. Please contact us if you have any issues with this documentation. Software environment: \u00b6 Baltica framework is based on: - A python command-line interface - Snakemake workflows - Docker containers used with Singularity - R scripts for processing, integrating, annotating, assigning biological features, and reporting - a Rmarkdown report We have developed it on the following computer environments: - Distribution: Debian 10 - Kernel: 4.19.0-16-amd64 - gcc version: 8.3.0 - Python version: 3.7.7 - Singularity version: 3.7.3 - Snakemake version: 6.4.1 - Git version: 2.20.1 These versions should not matter because the workflows are run within Docker containers, as long Snakemake version > 6 and a recent Singularity version . Baltica depends on python3, Singulary, and Snakemake: - How to install Singularity - How to install Snakemake Installation \u00b6 git clone https://github.com/dieterich-lab/baltica cd baltica pip install . Will install Baltica and its python dependencies. You may want to create a virtual environment before installing Baltica. All other requirements are resolved with singularity containers. Baltica store its singularity containers at $HOME/.baltica/singularity/ . Note We plan to submit Baltica to the Python Package Index. Warning majiq requires an Academic or Commercial license for use. Users are required to obtain their licenses. . Executing Baltica \u00b6 Use baltica cli for current help documentation: baltica --help Baltica executor takes a single optional argument --verbose , to detail its execution. Every other option is passed to Snakemake. Test dataset \u00b6 Baltica ships with a test dataset, located at the data/ directory. There is a configuration file for the test dataset. Users are required to update this configuration file . Please see the Baltica project configuration for further details. Cluster profile \u00b6 Snakemake supports distributed workflow execution in many different high-performance computer clusters, as detailed here . We recommend using cluster profiles and using it like: baltica <workflow> <config> --use-singularity --profile <cluster> (Advanced) Baltica workflows directly from Snakemake \u00b6 Baltica workflows can be used directly with Snakemake without installation. However, there is limited support for it.","title":"Getting started"},{"location":"setup.html#getting-started","text":"","title":"Getting started"},{"location":"setup.html#quick-example","text":"If Baltica dependencies, baltica configuration and cluster configuration are available, use: baltica <workflow> <config> --use-singularity Note Singularity requires a mountable temp directory, we recommend setting /tmp with export TMPDIR=/tmp/ workflow : all: run end-to-end wokflows qc: run quality control stringtie: run de novo and guided transcriptome assembly rmats junctionseq majiq leafcutter analysis: run scripts for integration, annotation and reporting config : project configuration file Use --profile <cluster> with a Snakemake cluster profile or set the number of avaiable cores with --cores . For more Snakemake parameters, check their documentation . Warning Baltica is under active development. Please contact us if you have any issues with this documentation.","title":"Quick example:"},{"location":"setup.html#software-environment","text":"Baltica framework is based on: - A python command-line interface - Snakemake workflows - Docker containers used with Singularity - R scripts for processing, integrating, annotating, assigning biological features, and reporting - a Rmarkdown report We have developed it on the following computer environments: - Distribution: Debian 10 - Kernel: 4.19.0-16-amd64 - gcc version: 8.3.0 - Python version: 3.7.7 - Singularity version: 3.7.3 - Snakemake version: 6.4.1 - Git version: 2.20.1 These versions should not matter because the workflows are run within Docker containers, as long Snakemake version > 6 and a recent Singularity version . Baltica depends on python3, Singulary, and Snakemake: - How to install Singularity - How to install Snakemake","title":"Software environment:"},{"location":"setup.html#installation","text":"git clone https://github.com/dieterich-lab/baltica cd baltica pip install . Will install Baltica and its python dependencies. You may want to create a virtual environment before installing Baltica. All other requirements are resolved with singularity containers. Baltica store its singularity containers at $HOME/.baltica/singularity/ . Note We plan to submit Baltica to the Python Package Index. Warning majiq requires an Academic or Commercial license for use. Users are required to obtain their licenses. .","title":"Installation"},{"location":"setup.html#executing-baltica","text":"Use baltica cli for current help documentation: baltica --help Baltica executor takes a single optional argument --verbose , to detail its execution. Every other option is passed to Snakemake.","title":"Executing Baltica"},{"location":"setup.html#test-dataset","text":"Baltica ships with a test dataset, located at the data/ directory. There is a configuration file for the test dataset. Users are required to update this configuration file . Please see the Baltica project configuration for further details.","title":"Test dataset"},{"location":"setup.html#cluster-profile","text":"Snakemake supports distributed workflow execution in many different high-performance computer clusters, as detailed here . We recommend using cluster profiles and using it like: baltica <workflow> <config> --use-singularity --profile <cluster>","title":"Cluster profile"},{"location":"setup.html#advanced-baltica-workflows-directly-from-snakemake","text":"Baltica workflows can be used directly with Snakemake without installation. However, there is limited support for it.","title":"(Advanced) Baltica workflows directly from Snakemake"},{"location":"tips.html","text":"snakemake takes --dry-run parameter that only computers and then output the list of task to be executed.","title":"Tips"},{"location":"tutorial.html","text":"Step by step tutorial with the sample data set \u00b6 Setup \u00b6 Make sure you have Singularity and Snakemake up and running. We have experienced problems with singularity pull and docker images when using a temporary directory (TMPDIR) in the shared file system. Setting TMPDIR=/tmp/ resolves this issue. Installation \u00b6 Follow Installation guide Configuration \u00b6 Open Baltica/data/config.yml and replace /beegfs/homes/tbrittoborges/ or /home/tbrittoborges to your desired path. The path parameter specifies where the project will be located. There is no needs to change baltica_path , as Baltica resolves it. Execution \u00b6 Execute Baltica with baltica all /Baltica/config.yml --use-singularity . Add --quiet to reduce the logging level or --verbose to increase it. Use a cluster profile ( --profile ) to take advantage of the cluster scheduler. See more useful parameters for snakemake below. You should expect a results/ directory containing the most relevant files by the end of the run. The report and excel table, results/baltica_report{project_title}.html and results/baltica_table{project_title}.xlsx , are the most relevant files. Intermediate files are kept in directories for each method (named for the methods), and can be used or deleted. Important snakemake parameters \u00b6 --cores : only required if you are not using a cluster scheduler. Use baltica ... --cores all to specify the maximum number of cores available. --profile : setup a cluster configuration profile . --dry-run : only computes the DAG, does not execute rules. But execution order may not reflect the actual order of execution. --unlock : unlock the directory if a previous run had problems. --list-untracked : list files that are not tracked by workflows, useful if you want to clean up the directory to save disk space after a successful run. --quiet : less verbose output. --reason , --printshellcmds , --verbose : verbose output. Simple use baltica ... --verbose to get maximum debug information (you may want to redirect it to a file). See more detail at the Snakemake docs .","title":"Tutorial"},{"location":"tutorial.html#step-by-step-tutorial-with-the-sample-data-set","text":"","title":"Step by step tutorial with the sample data set"},{"location":"tutorial.html#setup","text":"Make sure you have Singularity and Snakemake up and running. We have experienced problems with singularity pull and docker images when using a temporary directory (TMPDIR) in the shared file system. Setting TMPDIR=/tmp/ resolves this issue.","title":"Setup"},{"location":"tutorial.html#installation","text":"Follow Installation guide","title":"Installation"},{"location":"tutorial.html#configuration","text":"Open Baltica/data/config.yml and replace /beegfs/homes/tbrittoborges/ or /home/tbrittoborges to your desired path. The path parameter specifies where the project will be located. There is no needs to change baltica_path , as Baltica resolves it.","title":"Configuration"},{"location":"tutorial.html#execution","text":"Execute Baltica with baltica all /Baltica/config.yml --use-singularity . Add --quiet to reduce the logging level or --verbose to increase it. Use a cluster profile ( --profile ) to take advantage of the cluster scheduler. See more useful parameters for snakemake below. You should expect a results/ directory containing the most relevant files by the end of the run. The report and excel table, results/baltica_report{project_title}.html and results/baltica_table{project_title}.xlsx , are the most relevant files. Intermediate files are kept in directories for each method (named for the methods), and can be used or deleted.","title":"Execution"},{"location":"tutorial.html#important-snakemake-parameters","text":"--cores : only required if you are not using a cluster scheduler. Use baltica ... --cores all to specify the maximum number of cores available. --profile : setup a cluster configuration profile . --dry-run : only computes the DAG, does not execute rules. But execution order may not reflect the actual order of execution. --unlock : unlock the directory if a previous run had problems. --list-untracked : list files that are not tracked by workflows, useful if you want to clean up the directory to save disk space after a successful run. --quiet : less verbose output. --reason , --printshellcmds , --verbose : verbose output. Simple use baltica ... --verbose to get maximum debug information (you may want to redirect it to a file). See more detail at the Snakemake docs .","title":"Important snakemake parameters"},{"location":"workflows.html","text":"Workflow implementation \u00b6 This chapter details the implementation and usage of each workflow in Baltica. Baltica comprises a collection of Snakemake workflows (SMK files). Each file determines a series of sub-tasks (rules). The sub-tasks run in a specific order; once the output of every rule is complete, the workflow is considered successful. We implemented the workflows following instructions and parameters suggested by the methods authors unless otherwise noted. Fig. 1 - Baltica overview : Baltica is a framework to execute and integrate differential junction usage (DJU) analysis and further investigation enabled by the data integration. 1 -- Input : Baltica takes as input RNA-seq alignments, reference annotation, and a configuration file. 2 -- Quality control : As the first step of the pipeline, Baltica performs quality control of alignments with RSeQC and FastQC , which is reported by MultiQC . 3 -- DJU and transcriptome assembly : Next, Baltica computes DJU with JunctionSeq , Majiq , and Leafcutter , and uses Stringtie2 to detected new transcripts and exons in the dataset. 4 -- Downstream analysis : Finally, we integrate the results from the DJU method. Optionally, Baltica can include an extra piece of evidence for DJU, such as DJU obtained from third-generation sequencing, to the integrated table. The set of introns is re-annotated using information from de novo transcriptome annotation, and splice types between SJ and exons are assigned. Finally, a Baltica compiles a report with the most relevant information. Quality control workflow \u00b6 Executed with: baltica qc <config> --use-singularity The first workflow comprises the quality control of the read alignments. This step aims to determine the success of sequencing and alignment. Baltica includes workflows for RSeQC 1 and FastQC 2 . MultiQC 3 summarizes the output from both tools. In addition, users can use parameters from QC workflow into Baltica, such as maximum read length and library type. Beyond the quality control, this step may help to identify differences among the RNA libraries. For example, RSeQC provides the proportion of reads per feature in the input annotation. Differences between case vs. control, such as enrichment of reads aligned to introns, may suggest technical artifacts or global changes in splicing. In addition, RSeQC provides the junction_saturation.py method, which quantifies the abundance of known and novel SJ in the RNA-seq alignments, and diagnoses if the alignment coverage detects known and novel splice junctions in sub-samples for alignments. Thus, users can use this functionality to identify the saturation of annotated and unannotated SJ, or a higher level of coverage is needed. In conclusion, the quality control step serves to identify potential problems with the RNA-Seq library alignment and, potentially, direct on further troubleshooting and downstream analysis. Software dependencies RMATs workflow \u00b6 Executed with: baltica rmats <config> --use-singularity RMATs 4 workflow is done in two steps: - Determine the experimental groups. - Run rmats.py . Running RMATs prep and post tasks separately and paired statistical test were not implemented in Baltica. Software dependencies JunctionSeq workflow \u00b6 Executed with: baltica junctionseq <config> --use-singularity JunctionSeq 5 workflows starts by junction read counts extraction done with QoRTs 6 . In Baltica implementation for JunctionSeq workflow, we only consider reads that span multiple exons (splice junction reads, SJ) for annotated and unannotated introns, ignoring exon counts. JunctionSeq uses disjoint genomic bins to flatten the transcriptome annotation. To test the hypothesis that features are differently expressed in experimental groups, JunctionSeq fits a generalized linear model, as described in DEXSeq 7 , but reporting a test statistic at the genomic feature and gene level. Unlike other DJU methods, JunctionSeq does not group the introns or S in AS events, so it does not compute PSI events but rather log fold change. Baltica parses the *_sigGenes.results.txt.gz (located at junctionseq/analysis/ ) and discard entries that were flagged as not testable. Software dependencies and docker image recipe . Majiq workflow \u00b6 Executed with: baltica majiq <config> --use-singularity Majiq workflow includes the following steps: 1. Create a configuration file ( majiq/build.ini ) 1. Converts the reference annotation from gtf to gff with gtf2gff3.pl 1. majiq build generates the Splice Graph database with exons and SJ from the RNA-Seq experiment and the reference annotation 1. majiq deltapsi : computes \u03c8 and \u0394\u03c8 and tests if the \u0394\u03c8 significantly changes between comparisons. Introns are called significant if the probability of \u0394\u03c8 > threshold is higher than non-changing-threshold , where threshold and non-changing-threshold are the --threshold and --non-changing-threshold parameters, respectively 1. voila tsv : filter and outputs the Majiq result to a tab-separated value file Majiq visualization methods, such as voila view , are not currently implemented in Baltica but can be used independently. Baltica parses the {comparison}_voila.tsv files - one per comparison, located at majiq/voila/ . Docker image recipe . Leafcutter workflow \u00b6 Executed with: baltica leafcutter <config> --use-singularity Leafcutter uses Regtools 8 to extract SJ reads from the BAM files. Next, introns with at least minclureads reads clustered. The clustering procedure iteratively discards introns supported by less than mincluratio reads within a cluster. Finally, Leafcutter fits a Dirichlet-Multinominal model, which determines the SJ usage for each cluster the usage (proportion) of a giving SJ within a cluster and compare this usage among conditions The relevant output files from Leafcutter have the _cluster_significance.txt and _effect_sizes.txt suffix, computed for each comparison. Column description: *_cluster_significance.txt : 1. cluster : {chromosome}:{intron_start}:{intron_end} 1. Status : is this cluster testable? 1. loglr : the log-likelihood ratio between the null model and alternative 1. df : degrees of freedom, equal to the number of introns in the cluster minus one (assuming two groups) 1. p unadjusted p-value dor the under the asymptotic Chi-squared distribution *_effect_sizes.txt : 1. intron : intron identifier on the format chromosome:intron_start:intron_end:cluster_id 1. es : effect size 1. {cond_1} : fitted junction usage in condition cond_1 1. {cond_2} : fitted junction usage in condition cond_2 1. deltapsi : difference between usage in the two conditions Software dependencies and Docker image recipe . Stringtie workflow \u00b6 Baltica uses the gene, transcript, and class code assignments from the Stringtie output to the SJ from the DJU method outputs. In addition, exons defined by this annotation are used for assignments of splicing event types. We process de novo transcriptomic workflow with Stringtie 9 . First, we merge the alignment files from biological replicates. Next, we compute de novo annotation with Stringtie, using the parameters -c 3 -j 3 -f 0.01 . Finally, the merge the multiple annotation with gffcompare -r {reference_annotation.gtf} -R -V . Details on the parameter selection are in the Integration chapter . Docker image recipe References \u00b6 Liguo Wang, Shengqin Wang, and Wei Li. RSeQC: quality control of RNA-seq experiments. Bioinformatics , 28(16):2184\u20132185, June 2012. URL: https://doi.org/10.1093/bioinformatics/bts356 , doi:10.1093/bioinformatics/bts356 . \u21a9 Simon Andrews, Felix Krueger, Anne Segonds-Pichon, Laura Biggins, Christel Krueger, and Steven Wingett. FastQC. Babraham Institute, January 2012. URL: https://qubeshub.org/resources/fastqc . \u21a9 Philip Ewels, M\u00e5ns Magnusson, Sverker Lundin, and Max K\u00e4ller. MultiQC: summarize analysis results for multiple tools and samples in a single report. Bioinformatics , 32(19):3047\u20133048, Jun 2016. URL: http://dx.doi.org/10.1093/bioinformatics/btw354 , doi:10.1093/bioinformatics/btw354 . \u21a9 Shihao Shen, Juw Won Park, Zhi-xiang Lu, Lan Lin, Michael D. Henry, Ying Nian Wu, Qing Zhou, and Yi Xing. Rmats: robust and flexible detection of differential alternative splicing from replicate rna-seq data. Proceedings of the National Academy of Sciences , 111(51):E5593\u2013E5601, Dec 2014. URL: http://dx.doi.org/10.1073/pnas.1419161111 , doi:10.1073/pnas.1419161111 . \u21a9 Stephen W. Hartley and James C. Mullikin. Detection and visualization of differential splicing in RNA-seq data with JunctionSeq. Nucleic Acids Research , pages gkw501, June 2016. URL: https://doi.org/10.1093/nar/gkw501 , doi:10.1093/nar/gkw501 . \u21a9 Stephen W. Hartley and James C. Mullikin. QoRTs: a comprehensive toolset for quality control and data processing of RNA-seq experiments. BMC Bioinformatics , Jul 2015. URL: http://dx.doi.org/10.1186/s12859-015-0670-5 , doi:10.1186/s12859-015-0670-5 . \u21a9 S. Anders, A. Reyes, and W. Huber. Detecting differential usage of exons from RNA-seq data. Genome Research , 22(10):2008\u20132017, June 2012. URL: https://doi.org/10.1101/gr.133744.111 , doi:10.1101/gr.133744.111 . \u21a9 Kelsy C. Cotto, Yang-Yang Feng, Avinash Ramu, Zachary L. Skidmore, Jason Kunisaki, Megan Richters, Sharon Freshour, Yiing Lin, William C. Chapman, Ravindra Uppaluri, and et al. Regtools: integrated analysis of genomic and transcriptomic data for the discovery of splicing variants in cancer. pre-print, Oct 2018. URL: http://dx.doi.org/10.1101/436634 , doi:10.1101/436634 . \u21a9 Mihaela Pertea, Geo M Pertea, Corina M Antonescu, Tsung-Cheng Chang, Joshua T Mendell, and Steven L Salzberg. Stringtie enables improved reconstruction of a transcriptome from RNA-seq reads. Nature Biotechnology , 33(3):290\u2013295, Feb 2015. URL: http://dx.doi.org/10.1038/nbt.3122 , doi:10.1038/nbt.3122 . \u21a9","title":"Workflow implementation"},{"location":"workflows.html#workflow-implementation","text":"This chapter details the implementation and usage of each workflow in Baltica. Baltica comprises a collection of Snakemake workflows (SMK files). Each file determines a series of sub-tasks (rules). The sub-tasks run in a specific order; once the output of every rule is complete, the workflow is considered successful. We implemented the workflows following instructions and parameters suggested by the methods authors unless otherwise noted. Fig. 1 - Baltica overview : Baltica is a framework to execute and integrate differential junction usage (DJU) analysis and further investigation enabled by the data integration. 1 -- Input : Baltica takes as input RNA-seq alignments, reference annotation, and a configuration file. 2 -- Quality control : As the first step of the pipeline, Baltica performs quality control of alignments with RSeQC and FastQC , which is reported by MultiQC . 3 -- DJU and transcriptome assembly : Next, Baltica computes DJU with JunctionSeq , Majiq , and Leafcutter , and uses Stringtie2 to detected new transcripts and exons in the dataset. 4 -- Downstream analysis : Finally, we integrate the results from the DJU method. Optionally, Baltica can include an extra piece of evidence for DJU, such as DJU obtained from third-generation sequencing, to the integrated table. The set of introns is re-annotated using information from de novo transcriptome annotation, and splice types between SJ and exons are assigned. Finally, a Baltica compiles a report with the most relevant information.","title":"Workflow implementation"},{"location":"workflows.html#quality-control-workflow","text":"Executed with: baltica qc <config> --use-singularity The first workflow comprises the quality control of the read alignments. This step aims to determine the success of sequencing and alignment. Baltica includes workflows for RSeQC 1 and FastQC 2 . MultiQC 3 summarizes the output from both tools. In addition, users can use parameters from QC workflow into Baltica, such as maximum read length and library type. Beyond the quality control, this step may help to identify differences among the RNA libraries. For example, RSeQC provides the proportion of reads per feature in the input annotation. Differences between case vs. control, such as enrichment of reads aligned to introns, may suggest technical artifacts or global changes in splicing. In addition, RSeQC provides the junction_saturation.py method, which quantifies the abundance of known and novel SJ in the RNA-seq alignments, and diagnoses if the alignment coverage detects known and novel splice junctions in sub-samples for alignments. Thus, users can use this functionality to identify the saturation of annotated and unannotated SJ, or a higher level of coverage is needed. In conclusion, the quality control step serves to identify potential problems with the RNA-Seq library alignment and, potentially, direct on further troubleshooting and downstream analysis. Software dependencies","title":"Quality control workflow"},{"location":"workflows.html#rmats-workflow","text":"Executed with: baltica rmats <config> --use-singularity RMATs 4 workflow is done in two steps: - Determine the experimental groups. - Run rmats.py . Running RMATs prep and post tasks separately and paired statistical test were not implemented in Baltica. Software dependencies","title":"RMATs workflow"},{"location":"workflows.html#junctionseq-workflow","text":"Executed with: baltica junctionseq <config> --use-singularity JunctionSeq 5 workflows starts by junction read counts extraction done with QoRTs 6 . In Baltica implementation for JunctionSeq workflow, we only consider reads that span multiple exons (splice junction reads, SJ) for annotated and unannotated introns, ignoring exon counts. JunctionSeq uses disjoint genomic bins to flatten the transcriptome annotation. To test the hypothesis that features are differently expressed in experimental groups, JunctionSeq fits a generalized linear model, as described in DEXSeq 7 , but reporting a test statistic at the genomic feature and gene level. Unlike other DJU methods, JunctionSeq does not group the introns or S in AS events, so it does not compute PSI events but rather log fold change. Baltica parses the *_sigGenes.results.txt.gz (located at junctionseq/analysis/ ) and discard entries that were flagged as not testable. Software dependencies and docker image recipe .","title":"JunctionSeq workflow"},{"location":"workflows.html#majiq-workflow","text":"Executed with: baltica majiq <config> --use-singularity Majiq workflow includes the following steps: 1. Create a configuration file ( majiq/build.ini ) 1. Converts the reference annotation from gtf to gff with gtf2gff3.pl 1. majiq build generates the Splice Graph database with exons and SJ from the RNA-Seq experiment and the reference annotation 1. majiq deltapsi : computes \u03c8 and \u0394\u03c8 and tests if the \u0394\u03c8 significantly changes between comparisons. Introns are called significant if the probability of \u0394\u03c8 > threshold is higher than non-changing-threshold , where threshold and non-changing-threshold are the --threshold and --non-changing-threshold parameters, respectively 1. voila tsv : filter and outputs the Majiq result to a tab-separated value file Majiq visualization methods, such as voila view , are not currently implemented in Baltica but can be used independently. Baltica parses the {comparison}_voila.tsv files - one per comparison, located at majiq/voila/ . Docker image recipe .","title":"Majiq workflow"},{"location":"workflows.html#leafcutter-workflow","text":"Executed with: baltica leafcutter <config> --use-singularity Leafcutter uses Regtools 8 to extract SJ reads from the BAM files. Next, introns with at least minclureads reads clustered. The clustering procedure iteratively discards introns supported by less than mincluratio reads within a cluster. Finally, Leafcutter fits a Dirichlet-Multinominal model, which determines the SJ usage for each cluster the usage (proportion) of a giving SJ within a cluster and compare this usage among conditions The relevant output files from Leafcutter have the _cluster_significance.txt and _effect_sizes.txt suffix, computed for each comparison. Column description: *_cluster_significance.txt : 1. cluster : {chromosome}:{intron_start}:{intron_end} 1. Status : is this cluster testable? 1. loglr : the log-likelihood ratio between the null model and alternative 1. df : degrees of freedom, equal to the number of introns in the cluster minus one (assuming two groups) 1. p unadjusted p-value dor the under the asymptotic Chi-squared distribution *_effect_sizes.txt : 1. intron : intron identifier on the format chromosome:intron_start:intron_end:cluster_id 1. es : effect size 1. {cond_1} : fitted junction usage in condition cond_1 1. {cond_2} : fitted junction usage in condition cond_2 1. deltapsi : difference between usage in the two conditions Software dependencies and Docker image recipe .","title":"Leafcutter workflow"},{"location":"workflows.html#stringtie-workflow","text":"Baltica uses the gene, transcript, and class code assignments from the Stringtie output to the SJ from the DJU method outputs. In addition, exons defined by this annotation are used for assignments of splicing event types. We process de novo transcriptomic workflow with Stringtie 9 . First, we merge the alignment files from biological replicates. Next, we compute de novo annotation with Stringtie, using the parameters -c 3 -j 3 -f 0.01 . Finally, the merge the multiple annotation with gffcompare -r {reference_annotation.gtf} -R -V . Details on the parameter selection are in the Integration chapter . Docker image recipe","title":"Stringtie workflow"},{"location":"workflows.html#references","text":"Liguo Wang, Shengqin Wang, and Wei Li. RSeQC: quality control of RNA-seq experiments. Bioinformatics , 28(16):2184\u20132185, June 2012. URL: https://doi.org/10.1093/bioinformatics/bts356 , doi:10.1093/bioinformatics/bts356 . \u21a9 Simon Andrews, Felix Krueger, Anne Segonds-Pichon, Laura Biggins, Christel Krueger, and Steven Wingett. FastQC. Babraham Institute, January 2012. URL: https://qubeshub.org/resources/fastqc . \u21a9 Philip Ewels, M\u00e5ns Magnusson, Sverker Lundin, and Max K\u00e4ller. MultiQC: summarize analysis results for multiple tools and samples in a single report. Bioinformatics , 32(19):3047\u20133048, Jun 2016. URL: http://dx.doi.org/10.1093/bioinformatics/btw354 , doi:10.1093/bioinformatics/btw354 . \u21a9 Shihao Shen, Juw Won Park, Zhi-xiang Lu, Lan Lin, Michael D. Henry, Ying Nian Wu, Qing Zhou, and Yi Xing. Rmats: robust and flexible detection of differential alternative splicing from replicate rna-seq data. Proceedings of the National Academy of Sciences , 111(51):E5593\u2013E5601, Dec 2014. URL: http://dx.doi.org/10.1073/pnas.1419161111 , doi:10.1073/pnas.1419161111 . \u21a9 Stephen W. Hartley and James C. Mullikin. Detection and visualization of differential splicing in RNA-seq data with JunctionSeq. Nucleic Acids Research , pages gkw501, June 2016. URL: https://doi.org/10.1093/nar/gkw501 , doi:10.1093/nar/gkw501 . \u21a9 Stephen W. Hartley and James C. Mullikin. QoRTs: a comprehensive toolset for quality control and data processing of RNA-seq experiments. BMC Bioinformatics , Jul 2015. URL: http://dx.doi.org/10.1186/s12859-015-0670-5 , doi:10.1186/s12859-015-0670-5 . \u21a9 S. Anders, A. Reyes, and W. Huber. Detecting differential usage of exons from RNA-seq data. Genome Research , 22(10):2008\u20132017, June 2012. URL: https://doi.org/10.1101/gr.133744.111 , doi:10.1101/gr.133744.111 . \u21a9 Kelsy C. Cotto, Yang-Yang Feng, Avinash Ramu, Zachary L. Skidmore, Jason Kunisaki, Megan Richters, Sharon Freshour, Yiing Lin, William C. Chapman, Ravindra Uppaluri, and et al. Regtools: integrated analysis of genomic and transcriptomic data for the discovery of splicing variants in cancer. pre-print, Oct 2018. URL: http://dx.doi.org/10.1101/436634 , doi:10.1101/436634 . \u21a9 Mihaela Pertea, Geo M Pertea, Corina M Antonescu, Tsung-Cheng Chang, Joshua T Mendell, and Steven L Salzberg. Stringtie enables improved reconstruction of a transcriptome from RNA-seq reads. Nature Biotechnology , 33(3):290\u2013295, Feb 2015. URL: http://dx.doi.org/10.1038/nbt.3122 , doi:10.1038/nbt.3122 . \u21a9","title":"References"}]}